\documentclass[polish, twoside, 12pt]{mwart}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pdfpages}
\usepackage{booktabs}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{listings}

\usepackage{tabularx}
\usepackage{ltablex}
\newcolumntype{x}{p{4cm}}

\usepackage{tikz-qtree}

\usepackage{amsmath}

\usepackage{graphicx}
\graphicspath{ {../figures/} }

\let\stdsection\section
\renewcommand*{\section}{\clearpage\stdsection}
\emergencystretch=3em
\linespread{1.1}

\begin{document}

\includepdf{../templates/title-page}
 
\newpage

\tableofcontents

\newpage

\listoffigures
 
\listoftables

\newpage

\section{Wstęp}

Czasom, w których aplikacje internetowe pisane były od podstaw z wykorzystaniem natywnych możliwości oferowanych przez połączenie technologii \emph{HTML}, \emph{CSS} oraz \emph{JavaScript} zdecydowanie daleko do współczesności. Aktualnie programiści do wyboru mają ogromny zbiór gotowych platform programistycznych służacych do tworzenia aplikacji internetowych w języku \emph{JavaScript}.

Podjęcie decyzji, którą platformę użyć może być bardzo trudne, a fakt jej wybrania może mieć poważne konsekwencje w przyszłości z powodu kilku potencjalnych problemów. Jednym z takich problemów może sytuacja, w której popularna i szeroko rekomendowana przez społeczność programistów biblioteka traci na popularności z powodu nowego konkurenta. Konkurent ten oferuje wszystkie najbardziej lubiane cechy wcześniejszej biblioteki, przy okazji pozbywa się pewnych wad, a dodatkowo wprowadza swoje własne pomysły, czy też usprawnienia. Aktualnie wykorzystywana biblioteka przestaje być utrzymywana, w przypadku ujawnienia się luki związanej z bezpieczeństwem nie pojawia się tzw. łatka (ang. \emph{patch}). Programiści są wtedy zmuszeni do migracji do nowej biblioteki, bądź też do samodzielnego utrzymywania powoli wymierającej bilioteki.

Migracja może posiadać różny stopień skomplikowania. W idealnej sytuacji programiści podmieniają jedynie bibliotekę na inną, która zachowuje w pełni kompatybilny interfejs. Do takiej sytuacji możemy porównać wejście biblioteki \emph{React} \cite{react} w wersję \emph{16.0}, w której to implementacja głównego rdzenia została przepisana od podstaw, przy okazji nie wprowadzając zmian w interfejsie. Z drugiej strony można przytoczyć przykład bibliteki \emph{AngularJS} \cite{angularjs} oraz swojego następny o podobnej nazwie \emph{Angular} \cite{angular}. Pomimo podobieństwa w nazwie różnice są bardzo drastyczne i bibliotekę \emph{Angular} należy analizować jako zupełnie osobny byt.

Pomiędzy bibliotekami z rodziny \emph{Angular}, a \emph{React} aktualnie głównym konkurentem jest platforma \emph{Vue.js}, która czerpie garściami z lubianych oraz sprawdzonych funkcjonalności swoich konkurentów.

Jedną z mniej popularnych bibliotek jest \emph{mithril.js}. Chwali się on bardzo małą objętością oraz wysoką wydajnością w porównaniu do swoich konkurentów.

\subsection{Cel pracy}

Celem pracy jest porównanie pięciu platform programistycznych służących do tworzenia aplikacji internetowych. Są to \emph{Angular}, \emph{AngularJS},
\emph{mithril.js}, \emph{React} oraz \emph{Vue.js}. Porównanie zostanie przeprowadzone pod kątem wydajności czasowej oraz pamięciowej. Uzyskane wyniki pomóc mogą programistom zadecydować z jakiej biblioteki skorzystać jeśli ważnym elementem jest ich wydajność.

\subsection{Układ pracy}

Praca składa się z następujcych rozdziałów:

\begin{enumerate}
  \item \emph{Wstęp}
  \item \emph{Specyfikacja problemu}
  \item \emph{Środowisko przeglądarki internetowa} - zawiera opis działania przeglądarki internetowej oraz technologii jakie są wykorzystywane w środowisku przeglądarki internetowej do wyświetlenia aplikacji internetowej. W ramach tego rozdziału opisane zostały poszczególne kroki wyświetlania strony internetowej
  \item \emph{Trace Event Format} - w tym rozdziale opisany został format \emph{Trace Event Format}, w którym udostępniane są informacje przeglądarki \emph{Chrome}na temat wydajności.
  \item \emph{Chrome DevTools} - opis potężnego zbioru narzędzi przeglądarki \emph{Chrome}, który między innymi pozwala zapisać informacje na temat wydajności
  \item \emph{Aplikacje wspomagające badania} - w ramach pisania pracy magisterskiej stworzone zostały małe aplikacje, które w znaczący sposób usprawniły proces zbierania danych. Rozdział zawiera ich dokumentację.
  \item \emph{Platformy programistyczne do tworzenia aplikacji internetowych} - opis poszczególnych platform programistycznych oraz implementacji stworzonych za ich pomocą
  \item \emph{Badania wydajnościowe} - zawiera przeprowadzone badania oraz osiągniete wyniki
  \item \emph{Porównanie wyników i wnioski}
  \item \emph{Podsumowanie}
\end{enumerate}

\section{Specyfikacja problemu}

Aby w trakcie badań wydajnościowych uzyskać wyniki, które będzie można ze sobą porównywać wszystkie biblioteki będą implementowały taki sam schemat aplikacji.

\subsection{Schemat aplikacji testowej}

Aplikacja będzie składać się z nastepujących elementów dla każdej implementacji niezależnie od biblioteki:

\begin{enumerate}
  \item Inicjalizacja głównego komponentu/modułu - każda z bibliotek musi zostać zainicjalizowana, dzięki czemu zostanie wyrenderowany pierwszy komponent lub zostanie uruchomiony główny moduł odpowiedzialny za dalsze renderowanie
  \item Główny komponent - korzystając z biblioteki zaimplementowany zostać musi główny komponent, który odpowiedzialny będzie za pobranie listy elementów potrzebnych do wyrenderowania oraz zgłoszenia potrzeby aktualizacji tej listy. Główny komponent przekazywać będzie listę elementów do komponentu odpowiedzialnego za wyświetlenie elementów w tablicy
  \item Komponent tablicy elementów - komponent ten odpowiedzialny będzie za wyświetlenie stuktury tabeli, w której poszczególne wiersze odpowiadać będą elementom tablicy. Komponent musi reagować na zmiany elementów w tablicy i wyświetlać różnice najszybciej jak tylko jest w stanie to zrobić
\end{enumerate}

Aby przykładowa aplikacja bardziej przypominała przypadek ze świata rzeczywistego tablica przechowywać będzie elementy, które symulować będą stany wirtualnych maszyn. Na stan maszyny składać będą się takie parametry jak aktualne wykorzystanie procesora, aktualne wykorzystanie pamięci, aktualne wykorzystanie dysku, czas ciągłej pracy. W pojedyńczym wierszu tablicy będą również wyświetlane dane, które nie będą się zmieniać w czasie takie jak nazwa wirtualnej maszyny, całkowita dostępna pamięć, całkowita dostępna przestrzeń na dysku. Pozwoli to bibliotekom implementującym mechanizm wirtualnego obiektowego modelu dokumentu na wykorzystanie swoich zalet i ponowne użycie fragmentów \emph{DOM}, aby zminimalizować czas potrzebny do aktualizacji widoku.

Kod odpowiedzialny za generowanie tablicy oraz aktualizowanie ich elementów jest współdzielony pomiędzy wszystkimi bibliotekami, więc narzut czasowy oraz pamięciowy powinien być taki sam i nie powinien powodować przekłamań w uzyskanych wynikach badań.

\section{Środowisko przeglądarki internetowej}

Przeglądarka internetowa (ang. \emph{web browser}) to program komputerowy służący do pobierania i wyświetlania stron internetowych udostępnianych przez serwery \emph{WWW} (ang. \emph{World Wide Web}). Komunikacja z serwerem odbywa się najczęściej za pomocą protokołu \emph{HTTP} (ang. \emph{Hypertext Transfer Protocol})lub odpowiednika w wersji szyfrowanej \emph{HTTPS} (ang. \emph{Hypertext Transfer Protocol Secure}). Nierzadko przeglądarki internetowe są w stanie obsługiwać inne protokoły takie jak np. \emph{FTP} (ang. \emph{File Transfer Protocol}) wykorzystywany do serwerów plików, czy też protokoły \emph{POP3} (ang. \emph{Post Office Protocol}), \emph{IMAP} (ang. \emph{Internet Message Access Protocol}) i \emph{SMTP} (ang. \emph{Simple Mail Transfer Protocol}) wykorzystywane do poczty elektronicznej. 

\subsection{Technologie}

Współczesne strony internetowe to produkty, które powstały z połączenia wielu różnych technologii. Technologie te muszą być bardzo dobrze wspierane i obsługiwane przez przeglądarki internetowe. Działając razem pozwalają dostarczyć wysokiej jakości doświadczenia dla użytkownika (ang. \emph{User experience}). 

\subsubsection{HTML 5.1} \label{html}

Hipertekstowy język znaczników (ang. \emph{HyperText Markup Language}) to język służący do określenia struktury strony internetowej. Definicję \emph{HTML 5.1} stanowi \emph{W3C REC-HTML51} \cite{w3c-rec-html51}. Oprócz głównego tekstu \emph{HTML} zawiera tak zwane znaczniki, które zawierają dodatkowe informacje pozwalające przeglądarce internetowej odpowiednio zinterpretować określony fragment strony interetowej. Za pomocą znaczników możemy formować fragmenty strony w takie struktury takie jak hiperłącza, akapity, listy, nagłówki, czy też formularze. Znaczniki najczęściej występują w parach (jako znacznik otwierając oraz zamykający) definiując zakres swojego działania.

\lstinputlisting[language=HTML, caption=Przykładowa prosta strona internetowa z formularzem]{../examples/html.html}

Strona internetowa zaczyna się od \emph{<!DOCTYPE html>}. Jest to specjalny znacznik, który musi być umieszczony jako pierwszy. Informuje on przeglądarkę o tym, że tekst jest w formacie \emph{HTML}. Kolejnym znacznikiem jest \emph{html} z atrybutem \emph{lang}, jest to główny znacznik, będacy korzeniem całej zagnieżdzonej struktury. Atrybut \emph{lang} informuje przeglądarkę internetową o języku, dla którego strona jest dedykowana. Kolejnym znacznikiem jest znacznik \emph{head} zawierający infomację o systemie kodowania (w tym wypadku jest to  kodowanie \emph{UTF-8}) oraz tytuł strony. Może on zawierać dodatkowe metadane opisujące stronę internetową. Z punktu widzenia użytkownika najważniejszym fragmentem jest znacznik \emph{body}, który zawiera właściwą treść, czyli w tym wypadku jest to głównie formularz \emph{form}. Dwa najważniejsze atrybuty opisujące formularz to \emph{action} informujący przeglądarkę gdzie wysłać dane wpisane przez użytkownika oraz \emph{method} na podstawie, którego przeglądarka wie jaką metodę protokołu HTTP zastosować. Przykładowy formularz zawiera jedno pole tekstowe \emph{input type="text"} oraz jedno pole do wpisywania haseł \emph{input type="password"}. Hasło wpisane w tego typu pole jest domyślnie ukryte przez przeglądarkę dla celów bezpieczeństwa. Oba pola dodatkowo opisane są etykietami \emph{label}. Ostatnim nieopisanym jeszcze znacznikiem jest \emph{button type="submit"}, który wyświetlany jest jako przycisk służący do wysłania formularza. Każda przeglądarka posiada wbudowany zestaw styli, który definiuje wygląd każdego znacznika przewidzianego w dokumentacji \emph{HTML 5}.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{html-chrome.png}
	\caption{Przykład wyrenderowany w przeglądarce Chrome}
\end{figure}

\subsubsection{CSS 3}

Kaskadowe arkusze stylów (ang. \emph{Cascading Style Sheets}) to język służący do opisu wyświetlania struktury opisanej w języku \emph{HTML}. Wersja 3 składa się z wielu modułów. Każdy z nich dodaje nowe możliwości lub rozszerza te zdefiniowane w CSS 2 zachowując wsteczną kompatybilność (ang. \emph{backward compatibility}).

\begin{enumerate}
  \item css3-background - specyfikacja \emph{W3C REC-CSS3-Background} \cite{w3c-rec-css3-background}
  \item css3-box - specyfikacja \emph{W3C REC-CSS3-Box} \cite{w3c-rec-css3-box}
  \item css-cascade-3 - specyfikacja \emph{W3C REC-CSS-Cascade-3} \cite{w3c-rec-css3-cascade}
  \item css3-color - specyfikacja \emph{W3C REC-CSS3-Color} \cite{w3c-rec-css3-color}
  \item css3-content - specyfikacja \emph{W3C REC-CSS-Content-3} \cite{w3c-rec-css3-content}
  \item css-fonts-3 - specyfikacja \emph{W3C REC-CSS-Fonts-3} \cite{w3c-rec-css3-fonts}
  \item css3-gcpm - specyfikacja \emph{W3C REC-CSS-GCPM-3} \cite{w3c-rec-css3-gcpm}
  \item css3-layout - specyfikacja \emph{W3C REC-CSS-Template-3} \cite{w3c-rec-css3-template}
  \item css3-mediaqueries - specyfikacja \emph{W3C REC-CSS3-Mediaqueries} \cite{w3c-rec-css3-mediaqueries}
  \item css3-multicol - specyfikacja \emph{W3C REC-CSS3-Multicol} \cite{w3c-rec-css3-multicol}
  \item css3-page - specyfikacja \emph{W3C REC-CSS3-Page} \cite{w3c-rec-css3-page}
  \item css3-selectors - specyfikacja \emph{W3C REC-CSS3-Selectors} \cite{w3c-rec-css3-selectors}
  \item css-3-ui - \emph{W3C REC-CSS-UI-3} \cite{w3c-rec-css3-ui}
\end{enumerate}

Za pomocą \emph{CSS} opisać można wszystkie pojęcia odpowiedzialne za reprezentację elementów \emph{HTML}, takie jak rodzina czcionek, kolor tekstu, marginesy, czy też pozycja danego elementu względem innych elementów lub okna przeglądarki.

\emph{CSS} został stworzony w celu odseparowania struktury dokumentu od formy jego prezentacji. Zalety tej separacji to zwiększony zakres dostępności witryny, zmniejszona zawiłość dokumentu, łatwiejsze wprowadzanie zmian w strukturze dokumentu. \emph{CSS} ułatwia także zmiany w wyświetlaniu strony w zależności od obsługiwanego medium (ekran komputera, ekran tabletu, ekran telefonu komórkowego).

Arkusz stylów składa się z reguł określających styl dla wybranych elementów dokumentu. Reguła składa się z selektora oraz deklaracji. Selektor określa grupę elementów, którego ma dotyczyć deklaracja. Deklaracja określa formatowanie i składa się z nazwy jednej z właściwości i jej wartości napisanej po dwukropku. Deklaracja musi być otoczona nawiasami klamrowymi.

\begin{lstlisting}
selektor { 
	wlasciwosc: wartosc; 
}
\end{lstlisting}

Selektory oraz deklaracje można grupować. Zgrupowane selektory rozdziela się przecinkami, natomiast deklaracje średnikami.

\begin{lstlisting}
selektor, selektor2 { 
	wlasciwosc1: wartosc1;
	wlasciwosc2: wartosc2;
}
\end{lstlisting}

Selektory mogą poszukiwać elementy na podstawie wielu różnych wartośći, jedne z nich to:

\begin{itemize}
  \item nazwa elementu np. \emph{h1}
  \item atrybut \emph{class} elementu np. \emph{.my-class}
  \item identyfikator elementu, czyli atrybut \emph{id} np. \emph{\#element-id}
  \item połączenie wcześniejszych selektorów operatorem logicznym \emph{OR} np. \emph{h1.my-class}
  \item połączenie wcześniejszych selektorów operatorem logicznym \emph{AND} np. \emph{\#element-id .my-class}
\end{itemize}

Dobrą praktyką jest definiowanie selektorów na podstawie atrubutu \emph{class}, natomiast identyfikator, czyli atrybut \emph{id} powinien służyć do jednoznacznej identyfikacji elementu w strukturze \emph{HTML}. Zgodnie z dokumentacją wiele znaczników może posiadać taką samą klasę, natomiast identyfikator aby spełniał swoje zadanie musi być unikalny.

Ponieważ standardowy wygląd znaczników jest bardzo prosty to dodatkowo nieostylowane strony internetowe zdarzają się bardzo rzadko. W celu pokazania jak duża może być różnica pomiędzy standardowym, a specjalnie ostylowanym wyglądem strony internetowej poniżej przedstawiony został poprzedni przykład strony z formularzem wzbogacony o bardzo lekką bibliotekę \emph{CSS} o nazwie \emph{Milligram} \cite{milligram}. Biblioteka ta jest bardza lekka, jej rozmiar wynosi tylko 2kB.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{html-css-chrome.png}
	\caption{Ostylowany przykład wyrenderowany w przeglądarce Chrome}
\end{figure}

\subsubsection{JavaScript}

\emph{JavaScript} to skryptowy język programowania, stworzony przez firmę Netscape, najczęściej stosowany na stronach internetowych. Pod koniec lat 90. XX wieku organizacja \emph{ECMA} wydała na podstawie JavaScriptu standard języka skryptowego o nazwie \emph{ECMAScript}. Najnowsza stabilna wersja \emph{ECMAScript} nosi nazwę \emph{ECMAScript 2016} \cite{es2016} i została wydana 17 czerwca 2016. Wersja ta często występuje pod nazwą \emph{ECMAScript 5} pomimo iż jest to forma odradzana i organizacja ECMA zapowiedziała, że stabilna wersja tego standardu będzie ogłaszana co rok i to właśnie rok wydania będzie oficjalnie odpowiadał numerowi wersji. 

Najczęściej spotykanym zastosowaniem języka JavaScript są strony \emph{WWW}. Skrypty napisane w tym języku najczęściej służą do zapewnienia interaktywności poprzez odpowiednie reagowanie na zdarzenia generowane przez użytkownika. Skrypty JavaScriptu uruchamiane przez strony internetowe mają znacznie ograniczony dostęp do komputera użytkownika. 

Platformy programistyczne, które zostaną zbadane w ramach pracy magisterskiej napisane są języku JavaScript. Wspomagają one proces pisania aplikacji internetowej dostarczając odpowiednich funkcji i organizująć strukturę strony internetowej zgodnie z wytycznymi konkretnej platformy programistycznej.

W języku \emph{HTML} za umieszczanie skryptów \emph{JavaScript} odpowiedzialny jest znacznik \emph{script} z opcjonalnymi parametrami \emph{type="text/javascript"} i \emph{language="javascript"}.

\emph{JavaScript} może zostać użyty również poza środowiskiem przeglądarki internetowej dzięki darmowemu środowisku uruchomieniowemu \emph{Node.js} \cite{node.js}. \emph{Node.js} zaprojektowany został do tworzenia wysoce skalowalnych aplikacji internetowych, szczególnie serwerów napisanych w języku \emph{JavaScript}. Architektura \emph{Node.js} składa się z silnika \emph{V8} \cite{v8} stworzonego przez Google i opiera się na sterowaniu zdarzeniami wykorzystującymi asynchroniczny system wejścia-wyjścia. Kod źródłowy jest otwarty (ang. \emph{open source}) i każdy może brać udział w jego rozwijaniu. Domyślnym menedżerem pakietów dla \emph{Node.js} jest \emph{Npm} \cite{npm}, jednak warto zapoznać się z alternatywnym rozwiązaniem o nazwie \emph{Yarn} \cite{yarn}. \emph{Yarn} oferuje szybsze pobieranie zależności, większe bezpieczeństwo poprzez dodatkowe sprawdzanie sum kontrolnych oraz bardziej płaska stuktura drzewa pobranych zależności.

\subsubsection{DOM} \label{dom}

Obiektowy model dokumentu (ang. \emph{Document Object Model}) to zespół klas i interfejsów programistycznych umożliwiających dostęp do elementów strony napisanej w języku \emph{HTML}. Istnieje kilka tzw. poziomów \emph{DOM} (ang. \emph{level}):

\begin{enumerate}
  \item DOM Level 0 - nie stanowi oficjalnego standardu \emph{W3C} \cite{w3c}, pierwotnie był modelem zaimplementowanym w przeglądarce Netscape Navigator 3.0, obecnie wspierają go wszystkie przeglądarki
  \item DOM Level 1 - specyfikacja \emph{W3C REC-DOM-Level-1} \cite{w3c-rec-dom-level-1} 
  \item DOM Level 2 - specyfikacja \emph{W3C REC-DOM-Level-2} \cite{w3c-rec-dom-level-2} 
  \item DOM Level 3 - definicję stanowi sześć specyfikacji
  \begin{itemize}
    \item DOM Level 3 Core - specyfikacja \emph{W3C DOM-Level-3-Core} \cite{w3c-rec-dom-level-3-core}
    \item DOM Level 3 Load and Save - specyfikacja \emph{W3C DOM-Level-3-LS} \cite{w3c-rec-dom-level-3-ls}
    \item DOM Level 3 XPath - specyfikacja \emph{W3C DOM-Level-3-XPath} \cite{w3c-rec-dom-level-3-xpath}
    \item DOM Level 3 Views and Formatting - specyfikacja \emph{W3C DOM-Level-3-Views} \cite{w3c-rec-dom-level-3-views}
    \item DOM Level 3 Requirements - specyfikacja \emph{W3C DOM-Level-3-Requirements} \cite{w3c-rec-dom-level-3-requirements}
    \item DOM Level 3 Validation - specyfikacja \emph{W3C DOM-Level-3-Val} \cite{w3c-rec-dom-level-3-val}
  \end{itemize}
\end{enumerate}

\emph{DOM} pozwala dokonywać dowolnych modyfikacji poprzez tworzenie, usuwanie i modyfikację tzw. węzłów (ang. \emph{nodes}). Początkowo nie istniał standardowy obiektowy model dokumentu. Twórcy najpopulaniejszych przeglądarek tworzyłi własne niezgodne ze sobą modele. Organizacja \emph{W3C} \cite{w3c} przygotowała ujednolicony standard obiektowego modelu dokumentu, w którym dokment jest dostępny pod postacią globalnego obiektu \emph{document}, który posiada metody do np. pobierania elementu na podstawie identyfikatora \emph{document.getElementById} lub na podstawie klasy \emph{document.getElementByClassName}. Standard \emph{W3C} definiuje interfejsy \emph{DOM} tylko dla języków \emph{JavaScript} i \emph{Java}.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \Tree[.html 
      [.head 
        [.meta ]
        [.title ]
      ]
      [.body 
        [.h2 ]
        [.form 
            [.label ]
            [.input ]
            [.label ]
            [.input ]
            [.button ]
        ]
      ]
    ]
  \end{tikzpicture}
  \caption{Drzewo \emph{DOM} wygenerowane dla przykładu opisanego w rozdziale \ref{html}}
\end{figure}

\subsubsection{CSSOM} \label{cssom}

Obiektowy model kaskadowych arkuszy stylów (ang. \emph{CSS Object Model}) to zespół interfejsów programistycznych umożliwiających dostęp do stylów napisanych w języku \emph{CSS}.

\emph{CSSOM} blokuje wszystko przed wyświetleniem tzn. przeglądarka internetowa nie zacząć renderować dopóki w pełni nie zostanie zakończona budowa \emph{CSSOM}. W przypadku nieoptymalnej struktury \emph{CSS} budowa może trwać bardzo długo co skutkuje widoczną dla użytkownika białą stroną bez zawartości.

\emph{CSSOM} musi być zbudowany na nowo z każdym przeładowaniem strony, oznacza to, iż nawet jeśli pliki \emph{CSS} zostały umieszczone w pamięci podręcznej (ang. \emph{cache}) to nie uchroni to przeglądarki przed koniecznością budowy \emph{CSSOM}.

Istnieje związek pomiędzy kaskadowymi arkuszami stylów, które przeglądarka ładuje i skryptami \emph{JavaScript} umieszczonymi na stronie. Żeby przeglądarka wyświetliła cokolwiek musi poprawnie zakończyć budowę \emph{CSSOM}, w przypadku gdy budowa ta zostanie wstrzymana przez skrypty czas potrzebny na wyświetlenie jakiegokolwiek elementu wzrośnie. W przypadku nieoptymalnej kombinacji skryptów oraz stylów czas ten może wzrosnąc drastycznie skutkując bardzo negatywnymi doświadczeniami użytkownika, w najgorszym wypadku spowodować zniechęcenie użytkownika do dalszego oczekiwania i opuszczenie strony.

\begin{figure}
  \centering
  \resizebox{\textwidth}{!}{
    \begin{tikzpicture}
      \Tree[.body(font-size:10px) 
        [.h1(font-size:1.6rem) ]
        [.form(font-size:1.4rem) 
          [.label(font-size:1.2rem) ]
          [.input(font-size:1.2rem) ]
        ]
        [.button(font-size:1.4rem) ]
      ]
    \end{tikzpicture}
  }
  \caption{Przykładowe drzewo \emph{CSSOM} wygenerowane dla przykładu opisanego w rozdziale \ref{html}}
\end{figure}
\subsubsection{HTTP/1.1} \label{http/1.1}

Protokół przesyłania dokumentów hipertekstowych (ang.\emph{(Hypertext Transfer Protocol)}) to protokół za pomocą którego przysła się żadania udostępnienia dokumentów z serwera \emph{WWW} oraz informacje z forumlarzy internetowych. Obecną definicję \emph{HTTP} stanowi \emph{RFC 2616} \cite{rfc2616}

Protokół \emph{HTTP} udostępnia znormalizowany sposób komunikowania się komputerów ze sobą. Określa on formę żądań (ang. \emph{requests}) klienta dotyczących danych oraz formę odpowiedzi (ang. \emph{responses}) serwera na te żądania. Klientem może być np. przeglądarka internetowa.  \emph{HTTP} jest zaliczany do protokołów bezstanowych (ang. \emph{stateless}) ponieważ nie zachowuje żadnych informacji o poprzednich transakcjach z klientem. Pozwala to znacznie zmniejszyć obciążenie serwera, jednak uniemożliwia zapamiętanie konkretnego stanu użytkownika w sytuacji gdy jest to potrzebne np. przy implementacji koszyka z zakupami w sklepie internetowym. Najczęstszym rozwiązaniem tego problemu jest wprowadzenie mechanizmu ciasteczek (ang. \emph{cookies}). Ciasteczka to mały fragment tekstu zawierający pary klucz-wartość. Przesyłane są one z każdym żądaniem do serwera. Alternatywne rozwiązania to ukryte parametry (gdy aktualna strona zawiera formularz) oraz parametry umieszczone w ujednoliconym formacie adresowania zasobów (ang. \emph{Uniform Resource Locator}.

Wywołania protokołu \emph{HTTP} zaczynają się od \url{http://}. \emph{HTTP} standardowo korzysta z portu numer 80 protokołu kontroli transmisji (ang. \emph{Transmission Control Protocol}).

Zapytanie \emph{HTTP} zaczynaja się od nazwy metody, która określa akcję jaką obiekt tworzący zapytanie chce wykonać na zasobie podstępnym pod określonym adresem. Dostępne metody to:

\begin{enumerate}
  \item \emph{GET} - pobranie zasobu
  \item \emph{HEAD} - pobranie informacji o zasobie, metoda stosowana do sprawdzania dostępności zasobu
  \item \emph{PUT} - aktualizacja zasobu
  \item \emph{POST} - stworzenie nowego zasobu
  \item \emph{DELETE} - usunięcie zasobu
  \item \emph{OPTIONS} - pobranie informacji o możliwych operacjach do wykonania na zasobie
  \item \emph{TRACE} - metoda stosowana do diagnostyki kanału komunikacyjnego
  \item \emph{PATCH} - częściowa aktualizacja zasobu
\end{enumerate}

Poniżej przedstawione przykładowe żądanie \emph{HTTP/1.1} przeglądarki Chrome i odpowiedź serwera opisanego w rozdziale \ref{server}.

\begin{lstlisting}[caption=Przykładowe żądanie \emph{HTTP/1.1}]
GET / HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 
  (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,
  image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4
\end{lstlisting}

\begin{lstlisting}[caption=Przykładowa odpowiedź \emph{HTTP/1.1}]
HTTP/1.1 200 OK
X-Powered-By: Express
Content-Type: text/html; charset=utf-8
Content-Length: 116
ETag: W/"74-IGpXmXtcB0E/yn+QbK3UFXMrMU8"
Date: Tue, 15 Aug 2017 10:28:41 GMT
Connection: keep-alive
\end{lstlisting}

\subsubsection{HTTPS} \label{https}

Bezpieczny protokół przesyłania dokumentów hipertekstowych (ang. \emph{Hypertext Transfer Protocol Secure}) to szyfrowana wersja protokołu \emph{HTTP}. Obecną definicję \emph{HTTPS} stanowi \emph{RFC 2660} \cite{rfc2660}

W odróżnieniu od protokołu \emph{HTTPS}, protokół \emph{HTTP} do komunikacji stosuje niezaszyfrowany tekst. HTTPS początkowo szyfrował dane za pomocą protokołu \emph{SSL} (ang. \emph{Secure Socket Layer}), natomiast obecnie używany jest protokół \emph{TLS} (ang. \emph{Transport Layer Security}). Szyfrowanie zapobiega przechwytywaniu i zmienianiu przesyłanych danych. 

Wywołania protokołu \emph{HTTPS} zaczynają się od \url{https://}. \emph{HTTPS} standardowo korzysta z portu numer 443 protokołu kontroli transmisji. 

\subsubsection{HTTP/2} \label{http/2}

Protokół \emph{HTTP/2} to unowocześniejszego protokołu \emph{HTTP/1.1}. Został on opracowany na podstawie wczesnych wersji ekperymentalnego protokołu \emph{SPDY} \cite{spdy}. Obecną definicję \emph{HTTP/2} stanowi \emph{RFC 7540} \cite{rfc7540}. W przeciwieństwie do wersji \emph{HTTP/1.1}, protokół \emph{HTTP/2} jest w pełni binarny. Format podobny do tekstu zrozumiałego dla człowieka zastąpiony został zbiorem tak zwanych ramek (ang. \emph{frames}) o ściśle określonym formacie i zastosowaniu. Poniżej przedstawiono najważniejsze zalety protokołu \emph{HTTP/2}.

\begin{enumerate}
  \item \emph{Multipleksowanie} - protokół nawiązuje tylko jedno trwałe połączenie z serwerem za pomocą którego pobierane są wszystkie pliku niezbędne do prawidłowego wyświetlenia strony
  \item \emph{Powiadomienia Push} - serwer może wysłać dodatkowe informacje np. może wysłać pliki, które są potrzebne do prawidłowego wyświetlenia strony zanim przeglądarka internetowa zauważy tą potrzebę i ją zgłosi
  \item \emph{Ustalanie priorytetów} - każde zapytanie o plik posiada swój priorytet, który nadawany jest przez serwer. Umożliwia to najpierw pobranie najważniejszych plików, które pozwolą wyrenderować kluczowe fragmenty strony internetowej, a następnie doczytać kolejne elementy
  \item \emph{Kompresja nagłówków} - protokół \emph{HTTP/2} unika duplikacji informacji występującyh pomiędzy różnymi nagłówkami i wysyła je w skompresowanym formacie
  \item \emph{Szyfrowanie} - pomimo, iż szyfrowanie według protokołu \emph{HTTP/2} nie jest wymagane to większość najważniejszych przeglądarek internetowych implementuje \emph{HTTP/2} wyłącznie z wykorzystaniem protokołu \emph{TLS}
\end{enumerate}

\subsection{Proces wyświetlania strony internetowej}

Końcowym produktem przeglądarki internetowej jest w pełni załadowana i wyrenderowana strona internetowa, która oferuje użytkownikowi wszystkie zaimplementowane wcześniej funkcjonalności. Proces, który jest odpowiedzialny za dostarczenie tego produktu można podzielić na cztery etapy.

\begin{enumerate}
  \item pobieranie
  \item parsowanie
  \item budowanie
  \item renderowanie
\end{enumerate}

\subsubsection{Pobieranie}

Proces ładowania strony internetowej w przeglądarce zaczyna się od pobrania treści strony internetowej wraz ze wszystkimi zasobami potrzebnymi do jej wyświetlenia.
Przeglądarka pobiera wszystkie elementy za pomocą żądań \emph{HTTP}. Użytkownik może rozpocząć pobieranie poprzez:

\begin{enumerate}
  \item wpisanie adresu strony internetowej
  \item kliknięcie na odnośnik przekierowujący do innej strony lub do podstrony aktualnej strony internetowej
  \item przeładowanie aktualnej strony internetowej
\end{enumerate}

Moment stworzenia pierwszego żądania równoznaczny jest z początkiem ładowania strony internetowej. Od tego momentu przeglądarka może zacząć zbierać dodatkowe informacje na temat wydajności np. o całkowitym czasie ładowania strony. Przeglądarka internetowa tworzy żądanie zgodnie z zasadami protokołu \emph{HTTP/1.1}, który został bardziej szczegółowo opisny w rozdziale \ref{http/1.1}. Jeśli serwer wspiera obsługę nowszej wersji \emph{HTTP/2} wtedy wykorzystany jest nowszy protokół opisany w rozdziale \ref{http/2}. Całe wykonanie żądania przez przeglądarkę możemy podzielić na poszczególne fazy:

\begin{enumerate}
  \item \emph{Kolejkowanie} - przeglądarka kolejkuje żądania w przypadku gdy:
    \begin{itemize}
      \item aktualnie istnieją inne żądania do przetworzenia o wyższym priorytecie
      \item aktualnie istnieje już sześć otwartych połączeń TCP dla konkretnego źródła (ang. \emph{origin}). Ograniczenie to dotyczy tylko \emph{HTTP/1.0} oraz \emph{HTTP/1.1}
    \end{itemize}
  \item \emph{Odroczenie} - żądanie czeka na swoją kolej na przetworzenie z przyczyn wymienionych we wcześniejszym podpunkcie
  \item \emph{Podgląd DNS} - przeglądarka stara się przetłumaczyć adres internetowy na adres \emph{IP} za pomocą usługi systemu nazw domenowych (ang. \emph{Domain Name System})
  \item \emph{Negocjowanie z pośrednikiem} - przeglądarka prowadzi negocjacje z serwerem pośredniczącym (ang. \emph{proxy})
  \item \emph{Wysłanie żądania} - przeglądarka wysyła żądanie do serwera
  \item \emph{Oczekiwanie} - przeglądarka oczekuje na pierwsze bajty odpowiedzi, w tym czasie mierzony jest parametr TTFB (ang. \emph{Time To First Byte}) oznaczający czas jaki minął zanim przeglądarka otrzymała pierwszy bajt odpowiedzi
  \item \emph{Pobieranie zawartości} - przeglądarka pobiera całą zawartość odpowiedzi
  \item \emph{Otrzymanie notyfikacji Push} - serwer wysyła dodatkowe dane dla przeglądarki, jest to element unikalny dla \emph{HTTP/2}
  \item \emph{Czytanie notyfikacji Push} - przeglądarka czyta oraz interpretuje otrzymane wcześniej dodatkowe dane
\end{enumerate}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{request-timing-chrome.png}
	\caption{Przykładowy widok przedstawiający czas trwania poszczególnych faz przetwarzania żądania wygenerowany za pomocą Chrome DevTools}
\end{figure}

\subsubsection{Parsowanie}

W momencie gdy przeglądarka w pełni przetworzy żądanie i otrzyma dokument w postaci pliku zawierającego kod \emph{HTML} wtedy następuje proces czytania treści tego pliku w procesie zwanym parsowaniem. Pod pojęciem parsowanie ukrywa się czytanie treści z uwzględnieniem analizy składniowej specyficznej dla konkretnego języka. W przypadku języka \emph{HTML} przeglądarka oczekuje poprawnie zdefiniowanych znaczników z właściwymi parametrami. 

Jeśli przeglądarka napotka znacznik odnoszący się do kolejnego zasobu wtedy proces parsowania zostaje zatrzymany i tworzone jest żądanie  w celu pobrania zawartości potrzebnej do pełnego wyświetlenia strony. Dopiero gdy przeglądarka pobierze cały zewnętrzny zasób proces parsowania zostaje kontynuowany. Znaczniki blokujące poprzez tworzenie odniesienia do zewnętrznego zasobu to:

\begin{enumerate}
  \item załączenie pliku ze stylami CSS
  \item załączenie pliku z kodem w języku JavaScript
  \item załączenie pliku graficznego
\end{enumerate}

\begin{lstlisting}[caption=Przykładowe załączenie pliku ze stylami \emph{css}]
<link rel="stylesheet" type="text/css" href="style.css">
\end{lstlisting}

\begin{lstlisting}[caption=Przykładowe załączenie pliku z kodem w języku \emph{JavaScript}]
<script type="text/javascript" src="script.js">
\end{lstlisting}

\begin{lstlisting}[caption=Przykładowe załączenie pliku graficznego]
<img src="image.png">
\end{lstlisting}

\subsubsection{Budowanie}

W chwili, w której przeglądarka zakończy parsowanie dokumentu i wszystkie zewnętrzne zasoby zostaną pobrane następuje proces budowania strony, czyli łączenia informacji znalezionych w głównym pliku \emph{HTML} oraz pobranych zasobach. Na budowę strony składają się trzy kroki:

\begin{enumerate}
  \item \emph{Konstrukcja DOM} - obiektowa reprezentacja struktury opisanej w pliku \emph{HTML}. Szerzej opisana w rozdziale \ref{dom}
  \item \emph{Konstrukcja CSSOM} - obiektowa reprezentacja kaskadowych arkuszy stylów. Szerzej opisana w rozdziale \ref{cssom}
  \item \emph{Konstrukcja drzewa renderowania (ang. Render Tree)} - drzewiasta struktura będąca połączeniem \emph{DOM} oraz \emph{CSSOM}, na podstawie którego przeglądarka jest w stanie poprawnie wyświetlić stronę internetową
\end{enumerate}

\subsubsection{Renderowanie}

Po wykonaniu wszystkich wcześniejszych kroków przeglądarka jest w końcu gotowa przejść do procesu renderowania. Większość współczesnych urządzeń odświeża ekran z częstotliwością 60 razy na sekundę. Jeśli aktualnie wykonywana jest jakaś animacja, przesuwanie lub użytkownik zwyczajnie przewija stronę internetową wtedy przeglądarka musi dopasować się do częstotliwości odświeżania urządzenia i przygotować nowy obrazek lub klatkę (ang. \emph{frame}) dla każdego pojedynczego odświeżenia ekranu. Każda z tych klatek posiada 16 milisekund na przygotowanie się do wyświetlenia. Wynika to z bardzo prostego obliczenia:

\begin{equation}
  \frac{1s}{60} = 16.66 ms
\end{equation}

Należy jednak pamiętać o tym, że przeglądarka posiada również swoje zadania do wykonania dlatego w rzewczywistości warto wykonać wszystkie własne zadania w czasie ponizej 10 milisekund. Po przekroczeniu tej wartości spada częstotliwość wyświetlania klatek co może objawiać się efektem migotania elementów wyświetlanych na ekranie. Migotanie jest niechcianym zjawiskiem ponieważ odbija się bardzo negatywnie na doświadczeniach użytkownika korzystającego ze strony internetowej.

Proces renderowania możemy podzielić na pięć postępujących po sobie etapów tzw. rurociągu (ang. \emph{pipeline}). Każdy z tych etapów ma znączacy wpływ na to w jaki sposób wyświetlone zostaną piksele na ekranie.

\begin{enumerate}
  \item \emph{JavaScript / CSS} - język \emph{JavaScript} może zostać użyty do zadań, które ostatecznie skutkują wizualnymi zwianami na ekranie. Do tego typu zadań możemy zaliczyć np. wywołanie animacji, sortowanie zestawu danych, dodawanie elementów do strony za pomocą interfejsów \emph{DOM}. Animacje mogą również być definiowane za pomocą kasakdowych arkuszy styli
  \item \emph{Kalkulacja styli} - służy do określenia które reguły \emph{CSS} zaaplikować do konkretnych elementów na podstawie pasujących selektorów oraz oblicza wartości poszczególnych właściwości \emph{CSS}
  \item \emph{Układ (ang. Layout)} - na tym etapie przeglądarka wie już co wyświetlić na podstawie \emph{DOM}, wie też w jaki sposób to wyświetlić na podstawie \emph{CSSOM} oraz zna relację pomiędzy tymi dwoma elementami na podstawie \emph{Render Tree}. Na tym etapie przeglądarka oblicza jak dużą przestrzeń elementy będą zajmować na ekranie. Obliczenia te są potrzebne ponieważ właściwości jednego elementu często wpływają relatywnie na inne. Przykładowo szerokość elementu \emph{body}, które umiejscowione jest bardzo wysoko blisko korzenia w drzewie elementów wpłynie na szerokość wszystkich podelementów aż do tzw. liści. Z racji dużej ilości obliczeń proces ten może mocno angażować procesor.
  \item \emph{Malowanie (ang. Paint)} - malowanie jest processem wypełniania poszczególnych pikseli na ekranie. Sprowadza się do wyświetlenia tekstu, kolorów, obrazków, obramowań, cieni, czyli głównie wszystkiego co wpływa na wizualną część każdego elementu. Najczęściej elementy malowane są na wielu powierzchniach popularnie nazywanych warstwami
  \item \emph{Kompozycja (ang. Compositing)} - ponieważ elementy strony mogły zostać potencjalnie namalowane na wielu różnych warstawach, przeglądarka musi wyświetlić warstwy w odpowiedniej kolejności. Dotyczy to szczególnie elementów, które wzajemnie na siebie nachodzą, od błędnej kompozycji może zależeć czy element, który powinien być przykryty przypadkowo zostanie wyrysowany na warstwie znajdującej się na samej górze
\end{enumerate}

Każda część rurociągu może potencjalnie wywołać efekt migotania dlatego też ważne jest dokładne zrozumienie jest co powoduje wyzwalanie poszczególnych części.

Czasami można spotkac się z określeniem rasteryzacji (ang. \emph{rasterization}) używanym jako synonim etapu malowania. Dzieję się tak dlatego ponieważ malowanie składa się z dwoch zadań:

\begin{enumerate}
  \item tworzenia listy prymitywnych elemtów do wyrysowania takich jak np. punkty, odcinki, krzywe, okręgi, koła, kwadraty
  \item wypełniania pikseli na ekranie
\end{enumerate}

To właśnie ostatnie z wymienionych zadań jest właściwą rasteryzacją, czyli działaniem polegającym na jak najwierniejszym przedstawieniu płaskiej figury geometrycznej na urządzeniu rastrowym, dysponującym skończoną rozdzielczością, w naszym przypadku na ekranie urządzenia. Warto przytoczyć tutaj fakt, iż niektóre implementacje wykonują wymienione zadania na różnych wątkach procesora (ang. \emph{threads}), jednak dzieje się to poza jakąkolwiek kontrolą programisty.

Przygotowanie klatki do wyświetenia nie zawsze musi przechodzić przez wszystkie pięć etapów rurociągu. Istnieją trzy kombinacje elementów, które odgrywają rolę przy przygotowaniu klatki w momencie gdy nastąpiła wizualna zmiana obojętnie czy z powodu kodu napisanego w języku \emph{JavaScript}, czy też z powodu zdefiniowanych styli \emph{CSS}.

\begin{enumerate}
  \item \emph{JavaScript / CSS > Style > Layout > Paint > Composite} - pełne przejście przez wszystkie etapy. Ma miejsce w momencie gdy zmienia się właściwość powiązana z układem elementów na stronie np. szerokość, wysokość, pozycja elementu. Przeglądarka musi sprawdzić wszystkie pozostałe elementy, dokonać odpowiednich obliczeń potrzebnych na pełne przemalowanie warstw, a ostatecznie dokonać ich kompozycji
  \item \emph{JavaScript / CSS > Style > Paint > Composite} - kombinacja ta ma miejsce w momencie gdy zmienia się właściwość powiązana wyłącznie z malowaniem strony jak np. tło, kolor tekstu. Przeglądarka nie musi wtedy na nowo opracowywać układu strony, co nie zmienia faktu, że musi przejść przez etap malowania
  \item \emph{JavaScript / CSS > Style > Composite} - najbardziej pożądana kombinacja ponieważ nie wymaga ani opracowania układu strony, ani jej przemalowania. Ma miejsce tylko gdy zmienia się właściwość nie powiązana ze wcześniej wymienionymi etapami
\end{enumerate}

\subsection{Model współbieżności oraz pętla zdarzeń}

Język JavaScript posiada model współbieżności oparty na pętli zdarzeń (ang. \emph{event loop}). Ten model różni się od modeli zaimplementowanych w innych językach jak np. \emph{C} lub \emph{Java}.

Poniższe sekcje wyjaśniają model teoretyczny. Nowoczesne silniki JavaScript implementują i optymalizują opisaną tutaj semantykę.

\subsubsection{Stos}

Wywołania funkcji tworzą ramki (ang. \emph{frames}), które odkładane są na strukturze danych o nazwie stos(ang. \emph{stack}).

\begin{lstlisting}
function foo(b) {
  var a = 1;
  return a + b;
}

function bar(x) {
  var y = 1;
  return foo(x * y);
}

console.log(bar(2));
\end{lstlisting}

Na przedstawionym przykładzie w momencie wywołania funkcji \emph{bar} zostaje utworzona pierwsza ramka przechowująca argumenty przekazane do tej funkcji oraz lokalne zmienne. Następnie gdy wewnątrz funkcji \emph{bar} wywoływana jest funkcja \emph{foo} tworzona jest druga ramka przechowująca te same informacje tj. przekazane argumenty oraz lokalne zmienne. Ramka umieszczana jest na samej górze stosu nad pierwszym elementem. Kiedy następuje powrót z funkcji \emph{foo} element na samej górze stosu zostaje zdjęty (pozostawiając tylko ramkę powiązaną z wywołaniem funkcji \emph{bar}). Po powrocie z funkcji \emph{bar} stos powonie staje się pusty.

\subsubsection{Sterta}

Obiekty utworzone w języku JavaScript są umieszczane w stercie (ang. \emph{heap}). Poprzez stertę rozumi się dużą w większości nieustrukturyzowaną przestrzeń pamięci.

\subsubsection{Kolejka}

Środowisko wykonawcze języka JavaScript zawiera kolejkę (ang. \emph{queue}), która składa się z wiadomości do przetworzenia. Funkcja jest przypisana do odpowiedniej wiadomości. W momencie gdy stos posiada wystarczająco dużo miejsca wiadomość jest pobierana z kolejki i przetwarzana. Przetwarzanie polega na wywołaniu skojarzonej funkcji, a tym samym utworzeniu początkowej ramki stosu.
Przetwarzanie wiadomości kończy się, gdy stos staje się pusty.

\subsubsection{Pętla zdarzeń}

Pętla zdarzeń uzyskała swoją nazwę ze względu na to, jak zwykle jest to implementowana. Działanie pętli zdarzen obrazuje poniższy pseudokod:

\begin{lstlisting}
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
\end{lstlisting}

Fragment \emph{queue.waitForMessage()} oczekuje synchronicznie, aż pojawi się wiadomość w kolejkce. Pętla zdarzen posiada kilka bardzo ważnych własności:

\begin{enumerate}
  \item \emph{Działanie do końca} - każda wiadomość jest przetwarzana całkowicie przed przetworzeniem jakiejkolwiek innej wiadomości. To zachowanie gwarantuje, iż raz wywołana funkcja będzie działać do końca przed uruchomieniem dowolnego innego kodu. Jako przykład innego działania można przedstawić język \emph{C}, gdzie np. jeśli funkcja dziąła w wątku może być zatrzymana w dowolnym momencie, aby uruchomić inny kod w innym wątku. Minusem tego modelu jest możliwość zaistnienia sytuacji w której przetwarzanie wiadomości trwa bardzo długo, w tym czasie aplikacja internetowa nie jest w stanie przetworzyć interakcji użytkownika. Przeglądarka obsługuje tą sytuację wyświetlając informację o tym, że wykonywanie skryptu trwa bardzo długo. Może to zniechęcić użytkownika do opuszczenia strony lub jej ponownego odświeżenia. Dobrą praktyką jest pisanie jak najkrótszej implementacji przetwarzania wiadomości
  \item \emph{Sposób dodawania wiadomości} - w przeglądarce internetowej wiadomości dodawane są do kolejki w dowolnym momencie, w którym zdarzenie to ma miejsce pod warunkiem, że została dodana funkcja nasłuchująca konkretnego wydarzenia. Bez nasłuchiwania zdarzenia wiadomość ulega przepadnięciu. Istnieje możliwość dodanie wiadomości do kolejki za pomocą funkcji \emph{setTimeout}. Wiadomość ta zostanie dodana do kolejki po upływie czasu podanego jako argument funkcji. W przypadku, w którym w kolejce nie ma innej wiadomości to nowo dodana wiadomość zostanie przetworzona od razu, jeśli istnieją jakieś inne, wtedy komunikat dodany metodą \emph{setTimeout} będzie musiał poczekać zanim nie zostaną one przetworzone. Z tego powodu argument podany jako czas wkazuje na minimalny czas, a nie na gwarantowany czas. Z tego powodu należy również mieć na uwadze fakt, iż wywołanie funkcji \emph{setTimeout} z opóżnieniem 0 milisekund nie spowoduje przetworzena wiadomości od razu. Wszystko zależy od aktualnego stopnia zapełnienia kolejki
  \item \emph{Brak blokowania} - w przeciwieńswie do wielu innych języków JavaScript nigdy się nie blokuje. Obsługa wejścia / wyjścia zazwyczaj odbywa się za pośrednictwem zdarzeń i wywołań zwrotnych. Tym samym gdy aplikacja nadal może przetwarzać inne rzeczy jak np. wprowadzanie danych przez użytkownika
\end{enumerate}

\section{Trace Event Format} \label{trace-event-format-section}

Dane zebrane z przeglądarki internetowej podczas testów wydajnościowych zapisane zostały w formacie o nazwie \emph{Trace Event Format} \cite{trace-event-format}. Struktura \emph{Trace Event Format} zgodna jest ze standardem przechowywania danych JSON (ang. \emph{JavaScript Object Notation}) \cite{json} i może występować w dwóch wariantach.

\subsection{Wariant tablicowy}

Plik przechowujący dane w wariancie tablicowym (ang. \emph{JSON Array Format}) składa się z jednej tablicy przechowującej obikety zarejestrowanych zdarzeń. Zdarzenia te nie muszą być poukładane chronologicznie według znaczników czasu. 

\begin{lstlisting}[caption=Przykładowy wariant tablicowy]
[{
  "name": "Asub",
  "cat": "PERF",
  "ph": "B",
  "pid": 22630,
  "tid": 22630,
  "ts": 829
}, {
  "name": "Asub",
  "cat": "PERF",
  "ph": "E",
  "pid": 22630,
  "tid": 22630,
  "ts": 833
}]
\end{lstlisting}

\subsection{Wariant obiektowy}

Plik przechowujący dane w wraciencie obiektowym (ang. \emph{JSON Object Format}) składa się z jednego, głównego obiektu. Obiekt ten może posiadać następujące pola:

\begin{enumerate}
  \item traceEvents - jedyne wymagane pole, które jest tablicą zarejestrowanych zdarzeń. Tablica ta odpowiada dokładnie wariantowi tablicowemu formatu \emph{Trace Event Format}
  \item displayTimeUnit - jednostka, w której podane zostały znaczniki czasu. Możliwe jednostki to \emph{ms} oraz \emph{ns}. Domyślna jednostka to \emph{ms}
  \item systemTraceEvents - ciąg znaków kompatybilnych z \emph{Linux ftrace} \cite{ftrace} lub \emph{Windows ETW} \cite{etw}
  \item powerTraceAsString - ciąg znaków kompatybilnych z \emph{BattOr} \cite {battor}
  \item stackFrames - struktura przechowująca informacje o ramkach odłożonych na stosie
  \item samples - tablica przechowująca dane rozszerzające traceEvents o informacje zarejestrowane na poziomie systemu operacyjnego 
\end{enumerate}

Dopuszczona jest możliwość definicji pól o nazwach innych niż wymienione wcześniej dla dodatkowego opisania danych (metadane).

\begin{lstlisting}[caption=Przykładowy wariant obiektowy]
{
  "traceEvents": [[{
    "name": "Asub",
    "cat": "PERF",
    "ph": "B",
    "pid": 22630,
    "tid": 22630,
    "ts": 829
  }, {
    "name": "Asub",
    "cat": "PERF",
    "ph": "E",
    "pid": 22630,
    "tid": 22630,
    "ts": 833
  }],
  "displayTimeUnit": "ns",
}
\end{lstlisting}

\subsection{Zdarzenia}

Podstawowymi obiektami, które można poddać analizie są zdarzenia. Istnieje kilka rodzajów zdarzeń. Poniżej przedstawiono pola występujące w każdym zdarzeniu niezależnie od jego typu:

\begin{enumerate}
  \item name - nazwa zdarzenia
  \item cat - kolekcja oddzielonych przecinkiem kategorii powiązanych ze zdarzeniem
  \item ph - pojedynczy znak określający typ zdarzenia. Table prawidłowych wartości została przedstawiona poniżej
  \item ts - znacznik czasowy zdarzenia podany z dokładnością do milisekundy
  \item tts - opcjonalny znacznik czasowy wątku zdarzenia podany z dokładnością do milisekundy
  \item pid - identyfikator procesu, który spowodował zaistnienie zdarzenia
  \item tid - identyfikator wątku, który spowodował zaistnienie zdarzenia
  \item args - argumenty, które zostały dostarczone dla zdarzenia
\end{enumerate}

\begin{center}
  \begin{tabularx}{\textwidth}{|X|X|}\hline
    \emph{Typ zdarzenia} & \emph{Fazy zdarzenia}\\ \hline
    Zdarzenia trwające (\emph{ang. duration events}) & \textbf{B} początek (\emph{ang. begin}),\newline
    \textbf{E} koniec (\emph{ang. end})\\ \hline
    Zdarzenia kompletne (\emph{ang. complete events}) & \textbf{X}\\ \hline
    Zdarzenia natychmiastowe (\emph{ang. instant events}) & \textbf{i, I}(przestarzałe)\\ \hline
    Zdarzenia zliczające (\emph{ang. counter events}) & \textbf{c}\\ \hline
    Zdarzenia asynchroniczne (\emph{ang. async events}) & \textbf{b} (początek),\newline
    \textbf{n} (natychmiastowe zdarzenie asynchroniczne),\newline
    \textbf{e} (koniec)\newline\newline
    \textit{Przestarzałe}\newline
    \textbf{S} (początek),\newline
    \textbf{T} (krok kolejny),\newline
    \textbf{p} (krok poprzedni),\newline
    \textbf{F} (koniec)\\ \hline
    Zdarzenia przepływające (\emph{ang. flow events}) & \textbf{s} (początek),\newline
    \textbf{t} (krok),\newline
    \textbf{f} (koniec)\\ \hline
    Zdarzenia obiektowe (\emph{ang. object events}) & \textbf{N} (stworzenie)\newline
    \textbf{O} (migawka)\newline
    \textbf{D} (zniszczenie)\\ \hline
    Zdarzenia z metadanymi (\emph{ang. metadata events}) & \textbf{M}\\ \hline
    Zdarzenia zrzutu pamięci (\emph{ang. memory dump events}) & \textbf{V} (zrzut pamięci globalnej)\newline
    \textbf{v} (zrzut pamięci procesu)\\ \hline
    Zdarzenia synchronizacji zegara (\emph{ang. clock sync events}) & \textbf{c}\\ \hline
    Zdarzenia kontekstowe (\emph{ang. context events}) & \textbf{(, )}\\ \hline
  \caption {Fazy zdarzeń i odpowiadające im typy}
  \end{tabularx}
\end{center}

Poniżej przedstawiono opis każdego z możliwych typów zdarzeń:

\begin{enumerate}
  \item zdarzenia trwające - umożliwiają określenie czasu trwania pracy nad danym wątkiem. Zdarzenia czasowe są określane przez typy \textbf{B} i \textbf{E}. Zdarzenie \textbf{B} musi nastąpić przed odpowiednim wydarzeniem \textbf{E}. Można zagnieżdżać zdarzenia \textbf{B} i \textbf{E}. Znaczniki czasowe dla zdarzeń muszą być ułożone w kolejności rosnącej dla danego wątku. Znaczniki czasu w różnych wątkach nie muszą być ułożone w kolejności rosnącej
  \item zdarzenia kompletne - każde kompletne zdarzenie logicznie łączy parę zdarzeń (\textbf{B} i \textbf{E}). Kompletne zdarzenia są oznaczone przez typ fazy \textbf{X}
  \item zdarzenia natychmiastowe - odpowiadają czemuś co miało miejsce lecz bez przypisanego czasu trwania
  \item zdarzenia zliczające - mogą śledzić wartość lub wiele wartości zmieniających się w czasie
  \item zdarzenia asynchroniczne - służą do rejestrowania asynchronicznych operacji. Mogą pochodzić zarówno z różnych procesów jak i wątków
  \item zdarzenia przepływające - z założenia są bardzo podobne do zdarzeń asynchronicznych, ale dodatkowo pozwalają na łączenie ich ze sobą w wątkach i/lub procesach
  \item zdarzenia obiektowe - służą za konstrukcję do śledzenia złożonych struktur danych
  \item zdarzenia z metadanymi - są używane do powiązania dodatkowych informacji z wydarzeniami
  \item zdarzenia zrzutu pamięci - odpowiadają zrzutom pamięci procesu lub grupie procesów
  \item zdarzenia synchronizacji zegara - służą do synchonizacji czasu w przypadku gdy zdarzenia rejestrowane są przez różne byty
  \item zdarzenia kontekstowe - są używane do oznaczania sekwencji zdarzeń
\end{enumerate}

\begin{lstlisting}[caption=Przykładowe zdarzenie]
{
  "name": "myName",
  "cat": "category,list",
  "ph": "B",
  "ts": 12345,
  "pid": 123,
  "tid": 456,
  "args": {
    "someArg": 1,
    "anotherArg": {
      "value": "my value"
    }
  }
\end{lstlisting}

\section{Chrome DevTools}

Aplikacją, która znacząco wspomaga zbieranie informacji na temat wydajności czasowej jak i pamięciowej jest \emph{Chrome DevTools} \cite{chrome-devtools}. Jest to aplikacja wbudowana w przeglądarkę \emph{Chrome}. Zawiera szereg narzędzi do badania aplikacji internetowych oraz wizualizacji zebranych danych.

\subsection{Uruchamianie Chrome DevTools}

Aby uruchomić \emph{Chrome DevTools} wystarczy pobrać i uruchomić przeglądarkę \emph{Chrome} \cite{chrome}, a następnie wykonać dowolny z poniższych sposóbow:

\begin{itemize}
  \item Wybrać opcję \emph{Więcej narzędzi -> Narzędzia developerskie} z głównego menu przeglądarki \emph{Chrome}
  \item Kliknąc prawym przyciskiem myszki w dowolny element strony internetowej, a następnie wybrać opcję \emph{Inspekcja elementu}
  \item Wcisnąć kombinację przycisków \emph{Control+Shift+I}
\end{itemize}

\subsection{Narzędzia Chrome DevTools}

\emph{Chrome DevTools} jest potężnym zbiorem narzędzi, na który składają się:

\begin{enumerate}
  \item Tryb urządzenia - wspomaga tworzenie stron internetowych z myślą o urządzeniach mobilnych takich jak np. smartfony. Korzystając z tego modułu możemy sprawdzić jak aplikacja zachowuje się przy różnych wielkościach ekranu, czy jest responsywna i czy pozwala bez przeszkód korzystać z funkcjonalności oferowanych przez stronę internetową. W trybie urządzenia możemy również emulować wbudowane w urządzenia czujniki jak np. GPS, czy też akcelerometr
  \item Zakładka \emph{Elementy} - służy do modyfikacji w czasie rzeczywistym \emph{DOM} oraz \emph{CSS} pojedynczego wybranego elementu lub wielu zgrupowanych za pomocą selektora. Zakładka ta pozwala również dokonać inspekcji wszystkich animacji znajdujących się na stronie
  \item Zakładka \emph{Konsola} - pozwala na wykonanie dowolnego poprawnego kodu \emph{JavaScript}. Z poziomu konsoli posiadamy dostęp do interfejsów \emph{DOM} i \emph{CSSOM} aktualnie załadowanej strony internetowej
  \item Zakładka \emph{Źródła} - dzięki tej zakładce możemy debugować dowolny skrypt napisany w języku \emph{JavaScript}, który został załączony do strony internetowej. Dzięki wbudowanemu interfejsowi graficznemu w łatwy sposób możemy umieszczać punkty wstrzymania (ang. \emph{brakepoint}) i wykonywać kod linijka po linijce podglądając w czasie rzeczywistym wartość wszystkich zmiennych oraz ramek odłożonych na stos
  \item Zakładka \emph{Sieć} - służy do podglądania zarówno wykresów czasowych ładowania poszczególnych elementów strony internetowej jak i nagłówków wszystkich żądań oraz odpowiedzi \emph{HTTP}
  \item Zakładka \emph{Wydajność} - zakładka ta została bardziej szczegółowo opisana w następnym podrozdziale, ponieważ stanowi kluczowe narzędzie do celów badań wydajnościowych
  \item Zakładka \emph{Pamięć} - służy do tworzenia migawki (ang. \emph{snapshot}) aktualnego stanu sterty. Pozwala również zbierać informacje o tym jak była alokowana pamięc komputerowa w trakcie działania aplikacji i reprezentować zebrane dane na wykresie czasowym
  \item Zakładka \emph{Aplikacja} - dostarcza wglądu do takich elementów aplikacji internetowej jak manifest, ciasteczka, pamięc podręczna, lokalny magazyn (ang. \emph{local storage}), magazyn sesji (ang. \emph{session storage}). Dodatkowo pozwala modyfikować tworzyć oraz modyfikować istniejące wpisy w czasie rzeczywistym
  \item Zakładka \emph{Bezpieczeństwo} - służy do rozwiązywania problemów związanych z certyfikatami internetowymi, za pomocą wbudowanej przeglądarki możemy zapoznać się ze szczegółowymi informacajami na temat każdego certyfikatu związanego ze stroną internetową
\end{enumerate}

\subsection{Manualne zbieranie danych}
Aby manualnie zebrać dane na temat wydajności można wykorzystać zakładkę \emph{Wydajność (ang. Performance)}, która dostępna jest bezpośrednio po uruchomieniu \emph{Chrome DevTools}. Po wybraniu tej zakładki możemy zebrać dane na dwa sposoby:

\begin{enumerate}
  \item Klikając przycisk reprezentujący czarną kropkę, spowoduje to nagrywanie (ang. \emph{recording}) wszelkich informacji od momentu wciśnięcia przycisku, strona internetowa jest już załadowana i uruchomiona w oknie przeglądarki. Nagrywanie należy zatrzymać klikając odpowiedni przycisk widoczny na ekranie
  \item Klikając przycisk reprezentujący kręcącą się strzałkę, spowoduje to przeładowanie strony internetowej i nagrywanie danych od samego początku procesu wczytywania strony internetowej aż do jej pełnego załadowania
\end{enumerate}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-recording-runtime.png}
	\caption{Nagrywanie danych w trakcie działania aplikacji}
\end{figure} 

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-recording-reload.png}
	\caption{Nagrywanie danych od momentu wczytywania strony}
\end{figure}

\subsection{Wizualizacja zebranych danych}

Po zatrzymaniu nagrywania narzędzie automatycznie dokona reprezentacji zebranych danych za pomocą kilku widoków.

\subsubsection{Widok zbiorczy}

Najwyżej położonym widokiem służacym przedstwieniu zebranych danych jest widok zbiorczy, który składa się z kilku wykresów. Częścią wspólną wszystkich wykresów jest pozioma oś reprezentująca upływający czas. Poniżej opisane zostały wszystkie wykresy wchodzące w skład widoku zbiorczego:

\begin{enumerate}
  \item \emph{FPS} - wykres ten przedstawia ilość klatek na sekundę, które przeglądarka była w stanie przygotować do wyświetlenia
  \item \emph{CPU} - wykres ten przedstawia zmieniające się w czasie zużycie procesora
  \item \emph{NET} - wykres przedstawia czas, w którym przeglądarka pobierała wszystkie zasoby potrzebne do wyświetlenia strony oraz czekała na rozwiązanie wszelkich żądań \emph{HTTP}
  \item \emph{HEAP} - wykres przestawiający ilość pamięci zajmowanej przez stertę. Bardzo dobrze widać na nim cykliczne działanie zbieracza nieużytków (ang. \emph{Garbage collector}), który jest jedną z metod automatycznego zarządzania dynamicznie przydzieloną pamięcią. Nagłe usuwanie ze sterty niepotrzebnych obiektów powoduje spadek na wykresie i powstawanie charakterystycznych "ząbków".
\end{enumerate}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-summary-view.png}
	\caption{Przykładowy wygenerowany wykres zbiorczy}
\end{figure}

\subsubsection{Widok sieci}

Widok sieci jest widokiem przedstawiającym w bardziej precyzyjny sposób odcinki czasu, w których ładowane były poszczególne zasoby.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-network-view.png}
	\caption{Przykładowy wygenerowany widok sieci}
\end{figure}

\subsubsection{Widok klatek}

Widok klatek jest bardzo małym wykresem przedstawiającym jak zmieniała się liczba klatek na sekundę.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-main-view.png}
	\caption{Przykładowy wygenerowany widok klatek}
\end{figure}

\subsubsection{Widok głównego wątku}

Widok głównego wątku pokazuje dokładnie jakie zadania były wykonywane przez główny wątek. Zadania te pogrupowane są w kategorie za pomocą kolorów:

\begin{enumerate}
  \item niebieski - obejmuje wszystkie zadania związane z ładowaniem zasobów (w tym parsowanie)
  \item żółty - obejmuje wszystkie zadania związane ze skrytami napisanymi w języku \emph{JavaScript}
  \item fioletowy - obejmuje wszystkie zadania związane z renderowaniem
  \item zielony - obejmuje wszystkie zadanie związane z malowaniem
  \item szary - obejmuje wszystkie pozostałe zadanie nie wpasowujące się w pozostałe kategorie
  \item biały - przedstawia okres bezczynności, w którym nie były wykonywane żadne zadania
\end{enumerate}

Przyjęta kolorystyka jest spójna dla wszystkich widoków zakładki \emph{Wydajność}. Po wskazaniu kursorem myszki dowolnego elementu wyświetlone zostają bardziej szczegółowe informacje takie jak np. dokładny czas trwania zadania i jego źródło.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-frames-view.png}
	\caption{Przykładowy wygenerowany widok głównego wątku}
\end{figure}

\subsection{Manualne zbieranie danych pod kątek wydajności pamięciowej}

Aby manualnie zebrać dane na temat wydajności pamięciowej przed włączeniem nagrywania należy włączyć opcję zbierania informacji na temat zużycia pamięci. Dzięki temu uzyskamy dostęp do jednego dodatkowego widoku wykorzystania pamięci.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-memory-checkbox.png}
	\caption{Włączanie zbierania informacji na temat wykorzystania pamięci}
\end{figure}

\subsubsection{Widok wykorzystania pamięci}

Widok przedstawia jak w czasie zmienia się ilość pamięci zajętej przez stertę. Dodatkowo przedstawia on najmniejszą i najwięszką liczbę elementów w następujących kategoriach:

\begin{enumerate}
  \item Dokumenty (ang. \emph{Documents})
  \item Węzły (ang. \emph{Nodes})
  \item Funkcje nasłuchujące (ang. \emph{Listeners})
  \item Pamięc GPU (ang. \emph{GPU Memory})
\end{enumerate}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-memory-view.png}
	\caption{Przykładowy wygenerowany widok wykorzystania pamięci}
\end{figure}

\subsubsection{Zakładka \emph{Pamięć}}

\emph{Chrome DevTools} udostępnia specjalnie dedykowaną zakładkę o nazwie \emph{Pamięc}, która oferuje dodatkowe funkcjonalności przydatne przy np. debugowaniu aplikacji w celu znalezienia fragmentów kodu odpowiedzialnych za wyciek pamięci. Dostępne opcje to:

\begin{enumerate}
  \item migawka zawartości sterty - pozwala utrwalić aktualny stan sterty, a następnie dokonać przeglądu jej zawartości za pomocą wbudowanej przeglądarki
  \item nagranie profilu alokacji pamięci - pozwala zbierać dane na temat alokacji pamięci z poziomu kodu napisanego w języku \emph{JavaScript}
  \item alokacja pamięci przedstawiona na wykresie czasowym - pozwala zbierać dane na temat alokacji pamięci oraz automatycznie przedstawia je na osi czasowej
\end{enumerate}

Wszystkie opcje umożliwiają opcjonalne zapisanie zebranych danych do pliku na dysku.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-heap-snapshot.png}
	\caption{Przeglądarka zawartości utworzonej migawki sterty}
\end{figure}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-allocation-profile.png}
	\caption{Wykres wygenerowany na podstawie profilu alokacji pamięci}
\end{figure}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{chrome-devtools-performance-allocation-timeline.png}
	\caption{Wykres czasowy alokacji pamięci}
\end{figure}

\section{Aplikacje wspomagające badania}

W celu poprawnego przeprowadzenia badań zostały stworzone trzy małe aplikacje, które w znaczący sposób pomogły zebrać potrzebne dane. Głównym celem była automatyzacja wszystkich manualnych czynności. Osiągając cel główny udało się również zminimalizować efekt zniekształcenia pomiarów poprzez ręczną ingerencję człowieka.

\subsection{javascript-frameworks-benchmark}

\subsubsection{Opis}

\emph{javascript-frameworks-benchmark} to aplikacja, która przechowuje kod źródłowy wszystkich implementacji opartych na opisanych w pracy magisterskiej bibliotekach programistycznych. Po jej uruchomieniu pod lokalnym adresem \emph{http://localhost} i domyślnym porcie \emph{8080} dostępna jest strona za pomocą, której w łatwy sposób można przejść do wybranej przez siebie implementacji.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{javascript-frameworks-benchmark.png}
	\caption{Widok strony wyboru implementacji}
\end{figure}

\subsubsection{Specyfikacja wewnętrzna}

Aplikacja została napisana w języku \emph{JavaScript} w standardzie \emph{ECMAScript 2016} \cite{es2016}. Środowiskiem uruchomieniowym jest \emph{Node.js} \cite{node.js} w wersji \emph{8.1.4}. Do poprawnego zainstalowania zewnętrznych zależności potrzebny jest menedżer pakietów \emph{Yarn} \cite{yarn}. Serwer obsługujący żadania \emph{HTTP} oparty został na bibliotece \emph{Express} \cite{express}.

\subsubsection{Specyfikacja zewnętrzna}

\textbf{Sposób uruchomienia programu} \newline

Żeby uruchomić program należy przejść za pomocą konsoli do głównego folderu programu a następnie wywołać następujące komendy:

\begin{lstlisting}
yarn install
yarn start
\end{lstlisting}

\textbf{Format danych wejściowych} \newline

Aplikacja nie przyjmuje danych wejściowych. \newline

\textbf{Format danych wyjściowych} \newline

Aplikacja nie podaje żadnych danych na wyjściu. Po uruchomieniu odpowiada na żądania \emph{HTTP} pod domyślnym adresem \emph{http://localhost:8080}

\subsection{chrome-performance-logs-recorder}

\subsubsection{Opis}

\emph{chrome-performance-logs-recorder} to aplikacja, która w automatyczny sposób uruchamia przeglądarkę internetową, przechodzi pod określony adres a następnie zbiera informacje związane z wydajnością aby pod koniec zapisać je do pliku z rozszerzeniem \emph{JSON} w formacie \emph{Trace Event Format}.

\subsubsection{Specyfikacja wewnętrzna}

Aplikacja została napisana w języku \emph{JavaScript} w standardzie \emph{ECMAScript 2016} \cite{es2016}. Środowiskiem uruchomieniowym jest \emph{Node.js} \cite{node.js} w wersji \emph{8.1.4}. Do poprawnego zainstalowania zewnętrznych zależności potrzebny jest menedżer pakietów \emph{Yarn} \cite{yarn} oraz przeglądarka internetowa \emph{Chrome}.

Automatyczne działanie opiera się na uruchomieniu serwera \emph{Selenium} \cite{selenium}, który to uruchamia a następnie podłącza się do przeglądarki internetowej. Po podłączeniu się do przeglądarki \emph{Selenium} udostępnia interfejs programistyczny do większości akcji, które może robić standardowy użytkownik przeglądarki. Aby korzystać w pełni z funkcjonalności oferowanych przez \emph{Selenium} użyto wiązań (ang. \emph{bindings}) dostarczanych przez paczkę \emph{wd} \cite{wd}, które pozwalają na dostęp do interfejsu \emph{Selenium} z poziomu języka \emph{JavaScript} w środowisku \emph{Node.js}.

\subsubsection{Specyfikacja zewnętrzna}

\textbf{Sposób uruchomienia programu} \newline

Żeby uruchomić program należy przejść za pomocą konsoli do głównego folderu programu a następnie wywołać następujące komendy:

\begin{lstlisting}
yarn install
yarn ./build/main.js [parametry]
\end{lstlisting}

\textbf{Format danych wejściowych} \newline

Aplikacja przyjmuje następujące parametry:

\begin{itemize}
  \item \emph{-{}-debug} (domyślna wartość \emph{false}) - flaga włączająca dodatkowe infomacje na wyjściu
  \item \emph{-{}-duration} (domyślna wartość \emph{5000}) - czas zbierania informacji podanych w milisekundach
  \item \emph{-{}-filter-event-names} (domyślna wartość \emph{' '}) - odseprowane przecinkami nazwy zdarzeń, o których informacje mają być zbierane przez aplikację
  \item \emph{-{}-local-storage} (domyślna wartość \emph{key:value}) - pozwala zapisać w przeglądarce jedną parę klucz-wartość za pomocą mechanizmu przeglądarki \emph{LocalStorage}
  \item \emph{-{}-output-filename} (domyślna wartość \emph{'trace.json}) - nazwa pliku do którego mają zostać zapisane informacje
  \item \emph{-{}-silent} (domyślna wartość \emph{false}) - flaga wyłączająca wszelkie informacje na wyjściu
  \item \emph{-{}-trace-categories} (domyślna wartość \emph{'devtools.timeline,} \newline \emph{disabled-by-default-devtools.timeline.frame,rail'}) - odseparowane przecinkami kategorie zdarzeń, o których informacje mają być zbierane przez aplikację
  \item \emph{-{}-trim} (domyślna wartość \emph{0}) - podana w procentach ilość zdarzeń, która ma zostać obcięta z końcowego raportu (na początku oraz na końcu)
  \item \emph{-{}-url} (domyślna wartość \emph{' '}) - adres strony internetowej, na podstawie której mają być zbierane przez aplikację informacje
  \item \emph{-{}-verbose} (domyślna wartość \emph{false}) - flaga włączająca dodatkowe informacje na wyjściu
\end{itemize}

\textbf{Format danych wyjściowych} \newline

Dane wyjściowe zapisywane są do pliku z rozszerzeniem \emph{JSON} oraz są zgodne z opisanym wcześniej formatem \emph
{Trace Event Format} [\ref{trace-event-format-section}].

\subsection{trace-event-format-analyzer}

\subsubsection{Opis}

\emph{trace-event-format-analyzer} to aplikacja, która potrafi dokonać analizy statystycznej danych zarejestrowanych w formacie \emph{Trace Event Format}.

\subsubsection{Specyfikacja wewnętrzna}

Aplikacja została napisana w języku \emph{JavaScript} w standardzie ECMAScript 2016 \cite{es2016}. Środowiskiem uruchomieniowym jest \emph{Node.js} \cite{node.js} w wersji \emph{8.1.4}. Do poprawnego zainstalowania zewnętrznych zależności potrzebny jest menedżer pakietów \emph{Yarn} \cite{yarn}.

Aplikacja wczytuje plik z rozszerzeniem \emph{JSON} a następnie iteruje po kolekcji zdarzeń dokonując odpowiednich obliczeń.

\subsubsection{Specyfikacja zewnętrzna}

\textbf{Sposób uruchomienia programu} \newline

Żeby uruchomić program należy przejść za pomocą konsoli do głównego folderu programu a następnie wywołać następujące komendy:

\begin{lstlisting}
yarn install
yarn ./build/main.js [parametry]
\end{lstlisting}

\textbf{Format danych wejściowych} \newline

Aplikacja przyjmuje następujące parametry:

\begin{itemize}
  \item \emph{-{}-complete-events} (domyślna wartość \emph{' '}) - odseparowane przecinkami nazwy zdarzeń kompletnych, które mają zostać poddane analizie
  \item \emph{-{}-decimal-places} (domyślna wartość \emph{4}) - liczba miejsc po przecinku, do których mają zostać zaokrąglone wyniki
  \item \emph{-{}-duration-events} (domyślna wartość \emph{' '}) - odseparowane przecinkami nazwy zdarzeń trwających, które mają zostać poddane analizie
  \item \emph{-{}-immediate-events} (domyślna wartość \emph{' '}) - odseparowane przecinkami nazwy zdarzeń natychmiastowych, które mają zostać poddane analizie
  \item \emph{-{}-output} (domyślna wartość \emph{'false}) - flaga włączająca zapis analizy do pliku w formacie \emph{JSON}
  \item \emph{-{}-paths} (domyślna wartość \emph{' '}) - odseparowane przecinkami ścieżki plików, które mają zostać wczytane oraz poddane analizie
  \item \emph{-{}-silent} (domyślna wartość \emph{false}) - flaga wyłączająca wszelkie informacje na wyjściu
  \item \emph{-{}-verbose} (domyślna wartość \emph{false}) - flaga włączająca dodatkowe informacje na wyjściu
\end{itemize}

\textbf{Format danych wyjściowych} \newline

Dane wyjściowe, które opcjonalnie mogą zostać zapisane do pliku o rozszerzeniu \emph{JSON} są obiektem o następujących właściwościach:

\begin{enumerate}
  \item \emph{completeEvents} - obiekt zdarzeń kompletnych, którego właściwości odpowiadają nazwom analizowanych zdarzeń tego typu
  \item \emph{durationEvents} - obiekt zdarzeń trwających, którego właściwości odpowiadają nazwom analizowanych zdarzeń tego typu
  \item \emph{immediateEvents} - obiekt zdarzeń natychmiastowych, którego właściwości odpowiadają nazwom analizowanych zdarzeń tego typu
\end{enumerate}

Każdy obiekt odpowiadający konkretnemu zdarzeniu posiada następujące właściwości:

\begin{enumerate}
  \item \emph{deltas} - przechowuje wyliczone statystyki na podstawie czasu pomiędzy kolejnymi zdarzeniami (jednostka to milisekundy)
  \item \emph{eps} - przechowuje wyliczone statystyki na podstawie ilości zdarzeń na sekundę (jednostka to zdarzenia na sekundę)
\end{enumerate}

Obiekt przechowujący wyliczone statystyki posiada następujace właściwości:

\begin{enumerate}
  \item \emph{min} - minimalna zarejestrowana wartość
  \item \emph{mean} - średnia zarejestrowanych wartości
  \item \emph{percentiles} - obliczone percentyle kolejno 50\%, 66\%, 75\%, 80\%, 85\%, 90\%, 95\%, 98\%, 99\%, 100\%
  \item \emph{standardDeviation} - odchylenie standardowe
  \item \emph{variance} - wariancja
\end{enumerate}

\section{Platformy programistyczne do tworzenia aplikacji internetowych}

Aktualny wybór platform programistycznych do tworzenia aplikacji internetowych w języku \emph{JavaScript} jest bardzo szeroki. Zdecydowana większość bibliotek tworzona i utrzymywana jest zgodnie z zasadami wolnego oprogramowania \emph{Open Source}. Im większa popularność biblioteki tym większa szansa na wkład użytkowników w postaci nowych funkcjonalności, poprawiania błędów (w tym tych związanych z bezpieczeństwem), czy też optymalizacji. Podjęcie decyzji jakiej biblioteki użyć może być bardzo trudne zwłaszcza, że dosłownie z miesiąca na miesiąć może powstać nowa biblioteka zaskarbiająca sobie dużą sympatię programistów i tym samem pociągnać za sobą przepływ społeczeństwa zaangażowanego w tworzenie oprogramowania. 

\subsection{Charakterystyczne funkcjonalności}

Współczesne biblioteki często wzajemnie zapożyczają i implementują pomysły, czy też rozwiązania, które sprawdziły się w środowisku produkcyjnym. Rozwiązania te pozwalają na szybkie tworzenie oprogramowania przez doświadczonego programistę, ale narzucona struktura oprogramowania jest na tyle prosta, że może nad nim pracować osoba mniej doświadczona programistycznie. Niektóre ze stosowanych roziązań niosą pozytywne efekty również dla użytkownika końcowego w postaci szybko renderującej się i reagującej na akcje użytkownika strony internetowej.

\subsubsection{Komponenty}

Architektura strony internetwoej zbudowanej za pomocą współczesnych bibliotek programistycznych opiera się w zdecydowanej większości na idei komponentów. Poprzez komponenty rozumi się fragment strony internetowej, który posiada jasno określoną odpowiedzialność. Komponenty buduje się z połączenia \emph{HTML}, \emph{JavaScript} oraz \emph{CSS}, tym samym komponent zawiera wszystkie informacje potrzebne do wyświetlenia samego siebie oraz działania. Dzięki tej niezależności komponenty są w łatwy sposób testowalne, mają jasno określony interfejs za pomocą którego komunikują się z innymi komponentami. Raz określony komponent może być użyty w wielu miejscach co pozwala uniknąc niepotrzebnej duplikacji kodu.

Struktura strony internetowej opartej na komponentach może zostać przedstawiona za pomocą drzewa, którego korzeniem jest główny komponent, który najczęściej po prostu składa się z kilku komponentów o bardziej specyficznych odpowiedzialnościach. Te komponenty moga składać się z kolejnych i tak dalej. 

Komponenty mogą przechowywać swój aktualny stan potrzebny do poprawnego wyświetlenia oraz działania wykorzystując do tego zmienne o zakresie prywatnym to jest takim, który nie jest w żaden sposób udostępniany innym obiektom.

Kolejną charakterystyczną cechą komponentów jest ich cykl życia (ang. \emph{lifecycle}). Programista tworząc komponent może definiować fragmenty kodu, który zostanie uruchomiony w pewnych sytuacjach. Te sytuacje zależą od biblioteki ale najczęściej to moment w którym komponent zostaje stworzony, moment w którym zostaje niszczony oraz moment, w którym zmieniają się dostarczane do niego dane poprzez z góry określony interfejs.

\subsubsection{Wirtualny obiektowy model dokumentu}

Niektóre z bibliotek implementują mechanizm wirutalnego obiektowego modelu dokumentu (ang. \emph{ Virtual DOM}), jego głównym celem jest przyspieszenie działania aplikacji. Działanie tego mechanizmu polega na trzymaniu w pamięci kopii aktualnego obiektowego modelu dokumentu. W momencie, w którym DOM się zmienia np. w wyniku działania użytkownika najpierw modyfikowana jest wirtualna kopia przechowywana w pamięci. Po ustabilizowaniu się kopii wirtualnej zmiany nakładane są na rzeczywisty DOM.

Operacje wykonywane na kopii przechowywanej w pamięci są szybsze niż operowanie na rzeczywistym obiekcie. Dodatkowo liczba nakładanych zmian jest minimalna, oczekiwanie na stabilizację kopii pozwala uniknąć wprowadzania zmian, które są tymczasowe i nie mają miejsca w wersji finalnej.

\subsubsection{Wstrzykiwanie zależności}

Wstrzykiwania zależności (ang. \emph {Dependency injection}) jest jednym z bardziej popularnych wzorców projektowych oraz architektonicznych. Mechanizm ten jest jednym z możliwych sposobów dostarczania zależności do komponentów i usuwania bezpośrednich zależności pomiędzy komponentami.

Wstrzykiwanie zależności polega na przekazywaniu gotowych, utworzonych instancji obiektów do obiektów które z nich korzystają. Wstrzykiwanie zależności jest alternatywą do podejścia, w którym obiekty same tworzą instancję obiektów, z których korzystają. 

Użycie tej techniki pozwala tworzyć łatwo testowalne obiekty. Sprawdza się szczególnie w powiązaniu z programowaniem sterowanym testami (ang. \emph{test-driven development}). Programowanie to polega na następującym tworzeniu oprogramowania:

\begin{enumerate} 
  \item opracowanie interfejsów
  \item opracowanie testów jednostkowych, które testują funkcjonalności interfejsu
  \item właściwa implementacja
\end{enumerate}

Biblioteki mogą mieć wbudowany mechanizm wstrzykiwania zależności, lecz nie jest to regułą. \newline


\begin{center}
  \begin{tabularx}{\textwidth}{|X|X|X|X|X|X|}\hline
    & \emph{AngularJS} & \emph{Angular} & \emph{React} & \emph{Vue.js} & \emph{mithril.js}\\ \hline
    Rok wydania pierwszej wersji & 2009 & 2016 & 2013 & 2014 & 2014 \\ \hline
    Wersja badana & 1.6.5 & 4.3.3 & 15.6.1 & 2.4.2 & 1.1.3 \\ \hline
    Liczba kontrybutorów w serwisie GitHub & 1603 & 510 & 1099 & 144 & 202 \\ \hline
    Liczba gwiazdek w serwise GitHub & 57235 & 28483 & 77623 & 69281 & 8007 \\ \hline
    Kompo- nenty & Tak & Tak & Tak & Tak & Tak \\ \hline
    Wirtualny DOM & Nie & Nie & Tak & Tak & Tak \\ \hline
    Wstrzy- kiwanie zależności & Tak & Tak & Nie & Nie & Nie \\ \hline
    Wielkość po minifikacji & 171,7kB & 567,7kB & 20,7kB & 57,1kB & 22,5kB \\ \hline
    Wielkość po minifikacji i kompresji gzip & 59,6kB & 141,7kB & 6,9kB & 20,2kB & 8,1kB \\ \hline
    \caption{Porównanie bibliotek}
  \end{tabularx}
\end{center}

\subsection{AngularJS}

\subsubsection{Opis}

AngularJS \cite{angularjs} jest ciągle bardzo popularnym środowiskiem programistycznym, którego pierwsza wersja wydana została w 2009 roku. Aktualnie nie jest już dalej rozwijany na rzecz swojego następcy, czyli bardzo podobnie nazywającej się bilioteki o nazwie Angular. To co go odróżnia od innych bibliotek to wbudowany domyślnie mechanizm wstrzykiwania zależności kosztem mechanizmu wirtualnego obiektowego modelu dokumentu. Tak jak wszyscy konkurencji umożliwia tworzenie aplikacji za pomocą komponentów.

\subsubsection{Implementacja}

Inicjalizaca aplikacji napisanej za pomocą AngularJS polega na wywołaniu metody \emph{module} dostarczanej za pomocą globalnego obiektu \emph{angular}. Następnie za pomocą metody \emph{component} rejestrowane są poszczególne komponenty.

\begin{lstlisting}[caption=Inicjalizacja głównego modułu oraz rejestracja komponentów]
import angular from 'angular';

import PerformanceTest from
    './angularjs/performance-test.component';
import VirtualMachinesTable from
    './angularjs/virtual-machines-table.component';

const application = angular.module('application', []);

application.component(
    'performanceTest',
    PerformanceTest
);
application.component(
    'virtualMachinesTable',
    VirtualMachinesTable
);
\end{lstlisting}

Definicja głównego komponentu składa się z trzech plików odpowiednio: komponentu, kontrolera oraz widoku. Plik zawierający definicję komponentu łączy kontroler z konkretnym widokiem.

\begin{lstlisting}[caption=Główny komponent]
// performance-test.component.js
import PerformanceTestController from
    './performance-test.controller';

export default {
    template: require('./performance-test.template.pug')(),
    controller: PerformanceTestController
}

// performance-test.controller.js
import VirtualMachinesProvider from
    '../../helpers/virtual-machines-provider'

export default function ($scope, $timeout) {
    const virtualMachinesProvider =
        new VirtualMachinesProvider();
    
    $scope.virtualMachines = virtualMachinesProvider.get();
    
    const refresh = () => {
        virtualMachinesProvider.update();

        $timeout(refresh, 0);
    };

    refresh();
}

// performance-test.template.js
virtual-machines-table(
    virtual-machines="virtualMachines"
)
\end{lstlisting}

Komponent tabeli posiada zdefiniowaną tablicę wirtualnych maszyn za pomocą właściwości \emph{bindings}. Tablica ta zostanie przekazana automatycznie do kontrolera komponentu. Poszególne wiersze tabeli zostaną wygenerowane za pomocą atrybutu \emph{ng-repeat}, który to powieli określony fragment dla każdego elementu tabeli.

\begin{lstlisting}[caption=Komponent tabeli]
// virtual-machines-table.component.js
import VirtualMachinesTableController from
    './virtual-machines-table.controller';

export default {
    template: require('./virtual-machines-table.template.pug')(),
    controller: VirtualMachinesTableController,
    bindings: {
        virtualMachines: '<'
    }
}

// virtual-machines-table.controller.js
export default class VirtualMachinesTableController {}

// virtual-machines-table.template.js
table
thead
    tr
        th Name
        th Status
        th Average CPU load
        th Available memory [MB]
        th Used memory [MB]
        th Free memory [MB]
        th Available HDD [MB]
        th Free HDD [MB]
        th Used HDD [MB]
        th Uptime
tbody
    tr(
        ng-repeat="virtualMachine in $ctrl.virtualMachines"
    )
        td {{ virtualMachine.name }}
        td {{ virtualMachine.status }}
        td {{ virtualMachine.averageCpuLoad.toFixed(2) }}
        td {{ virtualMachine.memory.available.toFixed(0) }}
        td {{ virtualMachine.memory.used.toFixed(0) }}
        td {{ virtualMachine.memory.free.toFixed(0) }}
        td {{ virtualMachine.hdd.available.toFixed(0) }}
        td {{ virtualMachine.hdd.used.toFixed(0) }}
        td {{ virtualMachine.hdd.free.toFixed(0) }}
        td {{ virtualMachine.uptime }}
\end{lstlisting}

\subsection{Angular}

\subsubsection{Opis}

\emph{Angular} \cite{angular} to zyskujący coraz bardziej na popularności następca biblioteki \emph{AngularJS}. Bardzo podobna nazwa wprowadza wiele zamieszania, a sprawę nie ułatwia fakt, że początkowo biblioteka znana była pod nazwą \emph{Angular 2}. Dla osób dopiero co zapoznających się z tą biblioteką może to być bardzo mylące, zwłasza, że najnowsza jego wersja to \emph{4} i nie jest w pełni kompatybilna wstecznie z wersją \emph{2}. \emph{Angular} posiada wiele cech wspólnych z \emph{AngularJS} lecz różnić jest również jest na tyle dużo, że należy rozpatrywać tą bibliotekę jako zupełnie nowy byt. \emph{Angular} posiada mechanizm wstrzykiwania zależności oraz komponentów, nie posiada jednak mechanizmu wirtualnego obiektowego modelu dokumentu.

\subsubsection{Implementacja}

Inicjalizacja głównego modułu jest prosta i polega na wywołaniu funkcji \emph{platformBrowserDynamic} dostarczanej w paczce \emph{@angular/platform-browser-dynamic}. Jako parametr należy przekazać zdefiniowany główny moduł aplikacji.

\begin{lstlisting}[caption=Inicjalizacja głównego modułu]
import { platformBrowserDynamic } from
    '@angular/platform-browser-dynamic';

import { PerformanceTestModule } from
    './angular/performance-test.module';

platformBrowserDynamic().bootstrapModule(PerformanceTestModule);
\end{lstlisting}

Definicja głównego komponentu polega na zdefiniowaniu klasy udekorowanej dekoratorem \emph{@NgModule}. Wewnątrz tego modułu deklarujemy wszystkie komponenty dostępne wewnątrz aplikacji.

\begin{lstlisting}[caption=Główny moduł]
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { PerformanceTestComponent } from
    './performance-test.component';
import { VirtualMachinesTableComponent } from
    './virtual-machines-table.component';

@NgModule({
    bootstrap: [ PerformanceTestComponent ],
    declarations: [
        PerformanceTestComponent,
        VirtualMachinesTableComponent
    ],
    imports: [ BrowserModule ],

})
export class PerformanceTestModule {}
\end{lstlisting}

Główny komponent to klasa udekorowana dekoratorem \emph{@Component}. Dekorator ten odpowiedzialny jest za powiązanie klasy będącej odpowiednikiem kontrolera znanego z \emph{AngularJS} z odpowiednim widokiem.

\begin{lstlisting}[caption=Główny komponent]
// performance-test.component.ts
import { Component, OnInit } from '@angular/core';

import VirtualMachinesProvider from
    '../../helpers/virtual-machines-provider';
import { VirtualMachine } from
    './virtual-machine.interface';

declare const require: NodeRequireFunction;

const virtualMachinesProvider = new VirtualMachinesProvider();

@Component({
    selector: 'performance-test',
    template: require('./performance-test.template.pug')()
})
export class PerformanceTestComponent implements OnInit {
    public virtualMachines: VirtualMachine[];

    public constructor() {
        this.virtualMachines = virtualMachinesProvider.get();
    }

    public ngOnInit() {
        this.refresh();
    }

    private refresh = (): void => {
        virtualMachinesProvider.update();
        setTimeout(this.refresh, 0);
    }
}

// performance-test.template.pug
virtual-machines-table(
    [virtualMachines]="virtualMachines"
)
\end{lstlisting}

Komponent tabeli wykorzystuje ponownie dekorator \emph{@Component}. Komponent tabeli posiada zdefiniowaną tablicę wirtualnych maszyn za pomocą dekoratora \emph{@Input} użytego wewnątrz ciała klasy. Poszególne wiersze tabeli zostaną wygenerowane za pomocą atrybutu \emph{*ngFor}, który to powieli określony fragment dla każdego elementu tabeli.

\begin{lstlisting}[caption=Komponent tabeli]
// virtual-machines-table.component.ts
import { Component, Input } from '@angular/core';

import { VirtualMachine } from './virtual-machine.interface';

declare const require: NodeRequireFunction;

@Component({
    selector: 'virtual-machines-table',
    template: require('./virtual-machines-table.template.pug')()
})
export class VirtualMachinesTableComponent {
    @Input() public virtualMachines: VirtualMachine[];
}

// virtual-machines-table.template.pug
table
thead
    tr
        th Name
        th Status
        th Average CPU load
        th Available memory [MB]
        th Used memory [MB]
        th Free memory [MB]
        th Available HDD [MB]
        th Free HDD [MB]
        th Used HDD [MB]
        th Uptime
tbody
    tr(
        *ngFor="let virtualMachine of virtualMachines"
    )
        td {{ virtualMachine.name }}
        td {{ virtualMachine.status }}
        td {{ virtualMachine.averageCpuLoad.toFixed(2) }}
        td {{ virtualMachine.memory.available.toFixed(0) }}
        td {{ virtualMachine.memory.used.toFixed(0) }}
        td {{ virtualMachine.memory.free.toFixed(0) }}
        td {{ virtualMachine.hdd.available.toFixed(0) }}
        td {{ virtualMachine.hdd.used.toFixed(0) }}
        td {{ virtualMachine.hdd.free.toFixed(0) }}
        td {{ virtualMachine.uptime }}
\end{lstlisting}

\subsection{mithril.js}

\subsubsection{Opis}

\emph{mihtril.js} \cite{mithril.js} jest stosunkowo mało popularną biblioteką w porównaniu do swoich konkurentów. Jej niewątpliwą zaletą jest mała wielkość. Po minifikacji oraz kompresji gzip zajmuje około 8,1kB. Biblioteka ta nie posiada wbudowanego mechanizmu wstrzykiwania zależności. W odróżnieniu od obu bibliotek z rodziny \emph{Angular} posiada mechanizm wirtualnego obiektowego modelu dokumentu. Podobnie jak wszyscy swoi konkurencji pozwala definiować komponenty.

\subsubsection{Implementacja}

Inicjalizacja głównego komponentu jest bardzo prosta i sproawdza się do wywołania metody \emph{mount} udostępnianej przez obiekt \emph{m} dostarczany przez bibliotekę. Jako parametry przekazać należy obiekt z \emph{DOM} wewnątrz którego ma zostać zamontowany komponent przekazany jako drugi parametr.

\begin{lstlisting}[caption=Inicjalizacja głównego komponentu]
import m from 'mithril';

import PerformanceTestComponent from
    './mithril/performance-test.component';

const root = document.getElementById('root');

m.mount(root, PerformanceTestComponent)
\end{lstlisting}

Definicja głównego komponentu mieści się w jednym pliku i sprowadza się do zdefiniowania obiektu z odpowiednimi właściwościami.

\begin{lstlisting}[caption=Główny komponent]
import m from 'mithril';

import VirtualMachinesProvider from
    '../../helpers/virtual-machines-provider';
import VirtualMachinesTableComponent from
    './virtual-machines-table.component';

const virtualMachinesProvider = new VirtualMachinesProvider();

const PerformanceComponent = {
    virtualMachines: virtualMachinesProvider.get(),
    refresh: function () {
        virtualMachinesProvider.update();
        m.redraw();

        setTimeout(() => { this.refresh() }, 0);
    },
    oninit: function () {
        this.refresh();
    },
    view: function () {
        return m
            VirtualMachinesTableComponent,
            {virtualMachines: this.virtualMachines}
        );
    }
}

export default PerformanceComponent;
\end{lstlisting}

Komponent tabeli jest obiektem, który definiuje swój widok za pomocą odpowiednio zagnieżdżonych wywołań funkcji \emph{m} zwracającej instancje klasy \emph{VNode} będących wirtualną reprezentacją obiektów w \emph{DOM}. Przekazana tablica wirtualnych maszyn dostępna jest pod właściwością \emph{attrs}. Powielenie fragmentu dla każdego elementu tablicy odbywa się z wykorzystaniem standardowej funkcji \emph{map}.

\begin{lstlisting}[caption=Komponent tabeli]
import m from 'mithril';

const VirtualMachinesTableComponent = {
  view: function (vnode) {
    return m('table', [
      m('thead', [
          m('tr', [
              m('th', 'Name'),
              m('th', 'Status'),
              m('th', 'Average CPU load'),
              m('th', 'Available memory [MB]'),
              m('th', 'Used memory [MB]'),
              m('th', 'Free memory [MB]'),
              m('th', 'Available HDD [MB]'),
              m('th', 'Free HDD [MB]'),
              m('th', 'Used HDD [MB]'),
              m('th', 'Uptime')
          ])
      ]),
      m('tbody', [
        vnode.attrs.virtualMachines.map((virtualMachine) => {
          return m('tr', [
            m('td', virtualMachine.name),
            m('td', virtualMachine.status),
            m('td', virtualMachine.averageCpuLoad.toFixed(2)),
            m('td', virtualMachine.memory.available.toFixed(0)),
            m('td', virtualMachine.memory.used.toFixed(0)),
            m('td', virtualMachine.memory.free.toFixed(0)),
            m('td', virtualMachine.hdd.available.toFixed(0)),
            m('td', virtualMachine.hdd.used.toFixed(0)),
            m('td', virtualMachine.hdd.free.toFixed(0)),
            m('td', virtualMachine.uptime)
          ]);
        })
      ])
    ])
  }
}

export default VirtualMachinesTableComponent;
\end{lstlisting}

\subsection{React}

\subsubsection{Opis}

\emph{React} \cite{react} jest biblioteką stworzoną przez programistów popularnego serwisu społecznościowego \emph{Facebook}. W bardzo szybkim czasie zyskał on na popularności dzięki bardzo prostemu \emph{API} co pozwala w krótkim czasie czerpać ze wszystkich jego możliwości. \emph{API} biblioteki \emph{React} jest również bardzo stabilnie i nie wymaga wprowadzania drastycznych zmian w kodzie w celu przejścia do nowszej wersji. Biblioteka ta posiada mechanizm wirtualnego obiektowego modelu dokumentu, pozwala definiować komponenty, nie posiada natomiast wbudowanego mechanizmu wstrzykiwania zależności.

\subsubsection{Implementacja}

Implementacja główngo komponentu przebiega bardzo podobnie jak w przypadku biblioteki \emph{mithril.js}. Tym razem wykorzystać jednak nalezy metodę \emph{render} obiektu \emph{ReactDOM}.

\begin{lstlisting}[caption=Inicjalizacja głównego komponentu]
import React from 'react';
import ReactDOM from 'react-dom';

import PerformanceTest from
    './react/performance-test.component.jsx';

ReactDOM.render(
    <PerformanceTest/>,
    document.getElementById('root')
);
\end{lstlisting}

Główny komponent jest klasą rozszerzającą klasę \emph{React.Component} za pomocą słowa kluczowego \emph{extends}.

\begin{lstlisting}[caption=Główny komponent]
import React from 'react';

import VirtualMachinesProvider from
    '../../helpers/virtual-machines-provider';
import VirtualMachinesTable from
    './virtual-machines-table.component.jsx';

const virtualMachinesProvider = new VirtualMachinesProvider();

class PerformanceTest extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            virtualMachines: virtualMachinesProvider.get()
        };
    }

    refresh() {
        virtualMachinesProvider.update();

        this.setState(this.state);

        setTimeout(() => { this.refresh() }, 0);
    }

    componentDidMount() {
        this.refresh();
    }

    render() {
      return (
        <VirtualMachinesTable
            virtualMachines={this.state.virtualMachines}
        />
      );
    }
}

export default PerformanceTest;
\end{lstlisting}

Komponent tabeli jest klasą, która definiuje swój widok za pomocą metody \emph{render}. Metoda ta wykorzystuje format \emph{jsx} będący pomieszaniem języka \emph{JavaScript} z językiem \emph{HTML}
Przekazana tablica wirtualnych maszyn dostępna jest pod właściwością \emph{props}. Powielenie fragmentu dla każdego elementu tablicy odbywa się z wykorzystaniem standardowej funkcji \emph{map}.

\begin{lstlisting}[caption=Komponent tabeli]
import PropTypes from 'prop-types'; 
import React from 'react';

class VirtualMachinesTable extends React.Component {
  constructor(props) {
      super(props);
  }

  render() {
    return (
      <table>
          <thead>
              <tr>
                <th> Name </th>
                <th> Status </th>
                <th> Average CPU load </th>
                <th> Available memory [MB] </th>
                <th> Used memory [MB] </th>
                <th> Free memory [MB] </th>
                <th> Available HDD [MB] </th>
                <th> Free HDD [MB] </th>
                <th> Used HDD [MB] </th>
                <th> Uptime </th>
              </tr>
          </thead>
          <tbody>
            {this.props.virtualMachines
              .map((virtualMachine) => {
                return (
                  <tr key={virtualMachine.name}>
                    <td> {virtualMachine.name}</td>
                    <td> {virtualMachine.status}</td>
                    <td> {virtualMachine.averageCpuLoad
                            .toFixed(2)} 
                    </td>
                    <td> {virtualMachine.memory.available
                            .toFixed(0)}
                    </td>
                    <td> {virtualMachine.memory.used
                            .toFixed(0)}
                      </td>
                    <td> {virtualMachine.memory.free
                            .toFixed(0)}
                    </td>
                    <td> {virtualMachine.hdd.available
                            .toFixed(0)}
                    </td>
                    <td> {virtualMachine.hdd.used
                            .toFixed(0)}
                    </td>
                    <td> {virtualMachine.hdd.free
                            .toFixed(0)}
                    </td>
                    <td> {virtualMachine.uptime}
                    </td>
                  </tr>
                );
            })}
          </tbody>
      </table>
    );
  }
}

VirtualMachinesTable.propTypes = {
    virtualMachines: PropTypes.Array
};

export default VirtualMachinesTable;
\end{lstlisting}

\subsection{Vue.js}

\subsubsection{Opis}

\emph{Vue.js} \cite{vue.js} jest biblioteką stworzoną przez człowieka, który odszedł z grupy programistów tworzących bibliotekę \emph{AngularJS}, z tego powodu widać wiele inspiracji pochodzących z tej biblioteki.
Posiada te same cechy co \emph{mithril.js} oraz \emph{React}, czyli komponenty, mechanizm \emph{VDOM} oraz brak wstrzykiwania zależności.

\subsubsection{Implementacja}

Inicjalizacja aplikacji polega na stworzeniu nowej instancji klasy \emph{Vue} przekazując jako parametr główny komponent aplikacji. Rejestracja pozostałych komponentów wymaga wykorzystania statycznej metody \emph{component} klasy \emph{Vue}.

\begin{lstlisting}[caption=Inicjalizacja głównego komponentu]
import Vue from 'vue';

import PerformanceTestComponent from
    './vue/performance-test.component.vue';
import VirtualMachinesTableComponent from
    './vue/virtual-machines-table.component.vue';

Vue.component(
    'virtual-machines-table',
    VirtualMachinesTableComponent
);

new Vue(PerformanceTestComponent);
\end{lstlisting}

Definicja głównego komponentu wykorzystuje jeden plik o specyficznej konstrukcji. Część odpowiedzialna za widok przechowywana jest wewnątrz znacznika \emph{template}, natomiast część odpowiedzialna za logikę komponentu wewnątrz znacznika \emph{script}. Definicja logiki sprowadza sie do stworzenia obiektu z odpowiednimi właściwościami.

\begin{lstlisting}[caption=Główny komponent]
<template lang="pug">
  virtual-machines-table(
      v-bind:virtual-machines="virtualMachines"
  )
</template>

<script>
  import VirtualMachinesProvider from
    '../../helpers/virtual-machines-provider';

  const virtualMachinesProvider = new VirtualMachinesProvider();

  export default {
      created() {
          this.refresh();
      },
      data: {
          virtualMachines: virtualMachinesProvider.get()
      },
      el: '#root',
      methods: {
          refresh() {
              virtualMachinesProvider.update();
              setTimeout(() => { this.refresh() }, 0);
          }
      }
  }
</script>
\end{lstlisting}

Komponent tabeli również wykorzystuje specyficzny plik, który jest charakterystyczny dla biblioteki \emph{Vue.js}. Przekazana tablica wirtualnych maszyn dostępna jest pod właściwością \emph{props}. Powielenie fragmentu dla każdego elementu tablicy odbywa się z wykorzystaniem atrybutu \emph{v-for} bardzo podobnego do atybutów znanych z bibliotek z rodziny \emph{Angular}.

\begin{lstlisting}[caption=Komponent tabeli]
<template lang="pug">
  table
      thead
          tr
              th Name
              th Status
              th Average CPU load
              th Available memory [MB]
              th Used memory [MB]
              th Free memory [MB]
              th Available HDD [MB]
              th Free HDD [MB]
              th Used HDD [MB]
              th Uptime
      tbody
          tr(
              v-for="virtualMachine in virtualMachines"
          )
              td {{ virtualMachine.name }}
              td {{ virtualMachine.status }}
              td {{ virtualMachine.averageCpuLoad
                      .toFixed(2) }}
              td {{ virtualMachine.memory.available
                      .toFixed(0) }}
              td {{ virtualMachine.memory.used
                      .toFixed(0) }}
              td {{ virtualMachine.memory.free
                      .toFixed(0) }}
              td {{ virtualMachine.hdd.available
                      .toFixed(0) }}
              td {{ virtualMachine.hdd.used
                      .toFixed(0) }}
              td {{ virtualMachine.hdd.free
                      .toFixed(0) }}
              td {{ virtualMachine.uptime }}
</template>

<script>
  export default {
      props: {
          virtualMachines: Array
      }
  }
</script>
\end{lstlisting}

\section{Badania wydajnościowe}

Wszystkie badania przeprowadzone zostały na laptopie o następującej konfiguracji:

\begin{itemize}
  \item CPU - Intel(R) Core(TM) i5-2410M CPU @ 2.30GHz
  \item RAM - 8GB
  \item System operacyjny - Linux Mint 18.2 Sonya
\end{itemize}

Wersje oprogramowania:

\begin{itemize}
  \item \emph{Chrome} - 60.0.3112.90
  \item \emph{Node.js} - 8.1.4
\end{itemize}

Przeglądarka \emph{Chrome} została uruchomiona z następujacymi parametrami pozwalającymi uzyskać dokładniejsze wyniki badań:

\begin{itemize}
  \item -{}-disable-background-networking
  \item -{}-disable-component-extensions-with-background-pages
  \item -{}-metrics-recording-only
\end{itemize}

Badania pod kątem różnych platform programistycznych zostały przeprowadzone ze starannością, aby środowisko w trakcie badań było możliwie najbardziej identyczne. Ilość zbędnych procesów działających w tle została zmniejszona do minimum, w celu uzyskania jak najmniejszego przekłamania wyników końcowych.

Każda platforma programistyczna była testowana przez godzinę czasu dla liczby wirtualnych maszyn od 16 do 256 z krokiem równym 16 co daje 16 niezależnych pomiarów dla 5 platform, czyli łącznie 80 godzin pomiarów.

\subsection{Badania wydajności czasowej}

Rzeczywista liczba klatek na sekundę mierzona została na podstawie zdarzenia natychmiastowego o nazwie \emph{DrawFrame}. Zdarzenie to powstaje w momencie rysowania kolejnej klatki.

\subsubsection{Angular}

\begin{table}[]
  \centering
  \begin{tabular}{@{}lllllll@{}}
  \toprule
  Wirtualne maszyny      & 16      & 32      & 48      & 64      & 80      & 96      \\ \midrule
  Min                    & 35.8230 & 24.9327 & 21.5494 & 23.9550 & 22.2802 & 18.5598 \\
  Średnia arytmetyczna   & 60.3994 & 60.0407 & 59.6922 & 50.6024 & 43.6921 & 35.9992 \\
  Percentyl 50\%         & 59.8480 & 60.2482 & 59.9628 & 51.4430 & 44.3597 & 36.5430 \\
  Percentyl 66\%         & 62.2355 & 61.5006 & 60.5767 & 53.1011 & 45.2530 & 37.9737 \\
  Percentyl 75\%         & 63.7633 & 62.4103 & 61.0165 & 54.0950 & 45.7666 & 38.6309 \\
  Percentyl 80\%         & 64.5703 & 63.1712 & 61.5991 & 54.6538 & 46.0723 & 38.9879 \\
  Percentyl 90\%         & 66.4231 & 65.4322 & 63.3032 & 56.1577 & 46.9109 & 39.7472 \\
  Percentyl 95\%         & 70.0378 & 68.7002 & 64.6204 & 57.0483 & 47.4834 & 40.2674 \\
  Percentyl 98\%         & 74.0576 & 77.0416 & 67.1456 & 58.0013 & 48.1371 & 40.6141 \\
  Percentyl 99\%         & 77.4473 & 81.2876 & 68.5777 & 58.4215 & 48.9045 & 40.8230 \\
  Percentyl 100\%        & 94.2329 & 94.4287 & 84.3313 & 79.1077 & 76.6812 & 61.0426 \\
  Odchylenie standardowe & 5.5570  & 6.3691  & 4.1211  & 5.0946  & 3.5099  & 3.5984  \\
  Wariancja              & 30.8798 & 40.5659 & 16.9831 & 25.9550 & 12.3193 & 12.9487 \\ \bottomrule
  \end{tabular}
  \caption{Angular - klatki na sekundę (FPS) część 1}
\end{table}

\begin{table}[]
  \centering
  \begin{tabular}{@{}lllllll@{}}
  \toprule
  Wirtualne maszyny      & 112     & 128     & 144     & 160     & 172     & 188     \\ \midrule
  Min                    & 13.3774 & 13.4416 & 12.9958 & 11.1988 & 10.7087 & 9.8829  \\
  Średnia arytmetyczna   & 31.3300 & 29.1274 & 26.9256 & 24.1682 & 23.0777 & 21.3871 \\
  Percentyl 50\%         & 31.6546 & 29.7256 & 27.4514 & 24.5586 & 23.2250 & 21.5806 \\
  Percentyl 66\%         & 32.8926 & 30.7135 & 28.1080 & 25.5990 & 24.4021 & 22.5953 \\
  Percentyl 75\%         & 33.5087 & 31.1935 & 28.4843 & 25.9592 & 24.8102 & 23.0867 \\
  Percentyl 80\%         & 33.7861 & 31.4149 & 28.6944 & 26.1233 & 25.0138 & 23.2499 \\
  Percentyl 90\%         & 34.4887 & 31.9550 & 29.1639 & 26.5555 & 25.3762 & 23.6033 \\
  Percentyl 95\%         & 34.9626 & 32.3060 & 29.4707 & 26.8384 & 25.5846 & 23.8237 \\
  Percentyl 98\%         & 35.3582 & 32.6477 & 29.7992 & 27.1429 & 25.8104 & 24.0223 \\
  Percentyl 99\%         & 35.6570 & 32.9240 & 29.9895 & 27.3172 & 25.9572 & 24.2078 \\
  Percentyl 100\%        & 43.1444 & 34.6176 & 34.1052 & 29.3315 & 33.5852 & 28.8450 \\
  Odchylenie standardowe & 2.8201  & 2.8032  & 2.2607  & 2.3287  & 2.1408  & 2.0341  \\
  Wariancja              & 7.9532  & 7.8579  & 5.1106  & 5.4230  & 4.5829  & 4.1376  \\ \bottomrule
  \end{tabular}
  \caption{Angular - klatki na sekundę (FPS) część 2}
\end{table}

\begin{table}[]
  \centering
  \begin{tabular}{@{}llllll@{}}
  \toprule
  Wirtualne maszyny      & 204     & 220     & 232     & 248     & 256     \\ \midrule
  Min                    & 11.2600 & 9.9182  & 9.1410  & 9.6382  & 8.5746  \\
  Średnia arytmetyczna   & 19.9840 & 18.4973 & 18.2625 & 16.9970 & 16.6044 \\
  Percentyl 50\%         & 20.0868 & 18.3003 & 19.0002 & 17.1403 & 17.2372 \\
  Percentyl 66\%         & 20.7797 & 19.8708 & 19.3375 & 17.6604 & 17.6171 \\
  Percentyl 75\%         & 21.4500 & 20.2597 & 19.5137 & 18.3473 & 17.8403 \\
  Percentyl 80\%         & 21.6469 & 20.3965 & 19.6078 & 18.5398 & 17.9966 \\
  Percentyl 90\%         & 21.9964 & 20.6646 & 19.8444 & 18.8377 & 18.3180 \\
  Percentyl 95\%         & 22.1867 & 20.8364 & 20.0148 & 18.9970 & 18.5161 \\
  Percentyl 98\%         & 22.3619 & 20.9965 & 20.1853 & 19.1501 & 18.6386 \\
  Percentyl 99\%         & 22.4835 & 21.1042 & 20.2795 & 19.2701 & 18.7347 \\
  Percentyl 100\%        & 23.3738 & 22.6347 & 23.5555 & 22.2856 & 20.4011 \\
  Odchylenie standardowe & 1.6959  & 1.8333  & 1.8417  & 1.5722  & 1.7480  \\
  Wariancja              & 2.8761  & 3.3610  & 3.3918  & 2.4719  & 3.0554  \\ \bottomrule
  \end{tabular}
  \caption{Angular - klatki na sekundę (FPS) część 3}
\end{table}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{angular-fps.jpg}
	\caption{Angular - klatki na sekundę (FPS)}
\end{figure}

\subsection{Badania wydajności pamięciowej}

\section{Porównanie wyników i wnioski}

\section{Podsumowanie}

\subsection{Dalszy rozwój}

\begin{thebibliography}{11}
  \bibitem{react}
    \url https://reactjs.org/
  \bibitem{angularjs}
    \url https://angularjs.org/
  \bibitem{angular}
    \url https://angular.io/
  \bibitem{mithril.js}
    \url https://mithril.js.org
  \bibitem{vue.js}
    \url https://vuejs.org/
  \bibitem{ftrace}
    \url{https://www.kernel.org/doc/Documentation/trace/ftrace.txt}
  \bibitem{etw}
    \url{https://msdn.microsoft.com/pl-pl/library/windows/desktop/bb968803(v=vs.85).aspx}
  \bibitem{battor}
    \url{https://github.com/aschulm/battor}
  \bibitem{milligram}
    \url{http://milligram.io/}
  \bibitem{node.js}
    \url{http://nodejs.org/}
  \bibitem{v8}
    \url{https://github.com/v8/v8}
  \bibitem{npm}
    \url{https://www.npmjs.com/}
  \bibitem{yarn}
    \url{https://yarnpkg.com/}
  \bibitem{es2016}
    \url{https://www.ecma-international.org/ecma-262/7.0/}
  \bibitem{express}
    \url{https://expressjs.com/}
  \bibitem{selenium}
    \url{https://github.com/SeleniumHQ/selenium}
  \bibitem{wd}
    \url{https://github.com/admc/wd}
  \bibitem{spdy}
    \url{http://dev.chromium.org/spdy/}
  \bibitem{w3c}
    \url{https://www.w3.org/}
  \bibitem{w3c-rec-html51}
    \url{https://www.w3.org/TR/html51/}
  \bibitem{w3c-rec-css3-background}
    \url{https://www.w3.org/TR/css3-background/}
  \bibitem{w3c-rec-css3-box}
    \url{https://www.w3.org/TR/css3-box/}
  \bibitem{w3c-rec-css3-cascade}
    \url{https://www.w3.org/TR/css-cascade-3/}
  \bibitem{w3c-rec-css3-color}
    \url{https://www.w3.org/TR/css3-color/}
  \bibitem{w3c-rec-css3-content}
    \url{https://www.w3.org/TR/css-content-3/}
  \bibitem{w3c-rec-css3-fonts}
    \url{https://www.w3.org/TR/css-fonts-3/}
  \bibitem{w3c-rec-css3-gcpm}
    \url{https://www.w3.org/TR/css-gcpm-3/}
  \bibitem{w3c-rec-css3-template}
    \url{https://www.w3.org/TR/css-template-3/}
  \bibitem{w3c-rec-css3-mediaqueries}
    \url{https://www.w3.org/TR/css3-mediaqueries/}
  \bibitem{w3c-rec-css3-multicol}
    \url{https://www.w3.org/TR/css3-multicol/}
  \bibitem{w3c-rec-css3-page}
    \url{https://www.w3.org/TR/css3-page/}
  \bibitem{w3c-rec-css3-selectors}
    \url{https://www.w3.org/TR/css3-selectors/}
  \bibitem{w3c-rec-css3-ui}
    \url{https://www.w3.org/TR/css-ui-3/}
  \bibitem{w3c-rec-dom-level-1}
    \url{https://www.w3.org/TR/DOM-Level-1/}
  \bibitem{w3c-rec-dom-level-2}
    \url{https://www.w3.org/TR/DOM-Level-2/}
  \bibitem{w3c-rec-dom-level-3-core}
    \url{https://www.w3.org/TR/DOM-Level-3-Core/}
  \bibitem{w3c-rec-dom-level-3-ls}
    \url{https://www.w3.org/TR/DOM-Level-3-LS/}
  \bibitem{w3c-rec-dom-level-3-xpath}
    \url{https://www.w3.org/TR/DOM-Level-3-XPath/}
  \bibitem{w3c-rec-dom-level-3-views}
    \url{https://www.w3.org/TR/DOM-Level-3-Views/}
  \bibitem{w3c-rec-dom-level-3-requirements}
    \url{https://www.w3.org/TR/DOM-Requirements/}
  \bibitem{w3c-rec-dom-level-3-val}
    \url{https://www.w3.org/TR/DOM-Level-3-Val/}
  \bibitem{rfc2616}
    \url{https://www.ietf.org/rfc/rfc2616}
  \bibitem{rfc2660}
    \url{https://www.ietf.org/rfc/rfc2660}
  \bibitem{rfc7540}
    \url{https://www.ietf.org/rfc/rfc7540}
  \bibitem{chrome}
    \url{https://www.google.pl/chrome/browser/desktop/index.html}
  \bibitem{chrome-devtools}
    \url{https://developers.google.com/web/tools/chrome-devtools/}
  \bibitem{trace-event-format}
    \url{https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/edit}
  \bibitem{json}
    \url{http://www.json.org/}
\end{thebibliography}

\end{document}
